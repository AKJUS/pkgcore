python code guidelines.

lingo-
fex == for example
imo == in my opinion; 'my' refering to the author

Note not all of the existing code follows this.
Doesn't mean existing code is correct however ;)

---------------------------
Follow pep8, with following exemptions-

1) Use tabs for indentation
2) <80 char limit is only applicable where it doesn't make the logic ugly.
   This is not an excuse to have a 200 char if statement (fix your logic).  Use common sense.
3) combining imports is ok.
4) use absolute imports
5) _simple_ try/except combined lines are acceptable, but not forced (your call)- example
try: l.remove(blah)
except IndexError: pass
6) for comments. 2 spaces trailing is pointless- not needed.
7) classes should be named SomeClass , functions/methods should be named some_func
   Exceptions are classes.  Don't raise strings either.
8) avoid __var 'private' attributes unless you absolutely have a reason to hide it, 
   and the class won't be inherited (or that attribute must _not_ be accessed)
9) using string module functions when you could use a string method is evil.  Don't do it.
10) use isinstance(str_instance, basestring) unless you _really_ need to know if it's 
   utf8/ascii
   

---------------------------
Be aware of what the interpretter is actually doing.

1) Don't use len(list_instance) when you just want to know if it's nonempty/empty
l=[1]
if l: blah
# instead of
if len(l): blah

python looks for __nonzero__, then __len__.  It's a fair sight faster 
then if you try to be explicit there.

len(l) > ~= 0.456us
len(l) ~= 0.352us
l ~= 0.134us


2) don't explicitly use has_key.  rely on the 'in' operator.

python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' 'd.has_key(1999999)'
1000000 loops, best of 3: 0.512 usec per loop

python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' '1999999 in d'
1000000 loops, best of 3: 0.279 usec per loop

Python interprets the 'in' command by using __contains__ on the instance.  The interpretter
is faster at doing getattr's then actual python code is; fex, the code above uses
d.__contains__ , if you do d.has_key or d.__contains__, it's the same speed.  Using 
'in' instead has the interpretter do the lookup, and is faster.

So... be aware of how the interpretter will execute that code.  Python code specified attribute
access is slower then the interpretter doing it on it's own.

If in doubt, python -m timeit is your friend. ;-)


---------------------------
Do not use [] or {} as default args in function/method definitions.

>>> def f(default=[]):
>>>   default.append(1)
>>>   return default
>>> print f()
[1]
>>> print f()
[1,1]

When the function/class/method is defined, the default args are instantiated _then_, not per
call.  End result is that if it's a mutable default arg, you should use None and test; this is 
exempted if you _know_ the code doesn't mangle the default.


---------------------------
Visible curried functions should have documentation.

When using the currying methods (portage.util.currying) for function mangling, preserve the 
documentation via pretty_docs.

If this is exempted, pydoc output for objects isn't incredibly useful.


---------------------------
unit testing.

All code _should_ have test case functionality.  We use twisted.trial; should
be running >=2.2 (<2.2 results in false positives in the spawn tests).
Regressions should be test cased, exempting idiot mistakes (typos fex).

More then willing to look at code that lacks tests, but merging/integrating the code
requires tests.

One area that is (atm) exempted from this is the ebuild interaction; testing that interface
is extremely hard, although it _does_ need to be implemented.

If tests are missing from code (author didn't write tests initially), new tests desired. :)


---------------------------
If it's FS related code, it's _usually_ cheaper to try then to ask then try.
...but you should verify it ;)


python -m 'timeit' -s 'import os' 'os.path.exists("/etc/passwd") and open("/etc/passwd").read()'
10000 loops, best of 3: 37.5 usec per loop

	
python -m 'timeit' -s 'import os' $'try:open("/etc/passwd").read()\nexcept OSError: pass'
10000 loops, best of 3: 28.4 usec per loop

8.9 usec doesn't seem like much, but it adds up- specifically, the extra stat there
adds up.


Note that I qualified this with "If it's FS related code"; syscalls aren't cheap- if it's 
not triggering syscalls, next section is relevant.


---------------------------
Catching Exceptions in python code (rather then cpython) isn't cheap.

When an exception is caught-
python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' $'try: d[1999]\nexcept KeyError: pass'
100000 loops, best of 3: 5.57 usec per loop

python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' $'1999 in d and d[1999]'
1000000 loops, best of 3: 0.287 usec per loop


When no exception is caught, overhead of try/except setup

python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' $'try: d[0]\nexcept KeyError: pass'
1000000 loops, best of 3: 0.362 usec per loop

python -m 'timeit' -s 'd=dict(zip(range(1000), range(1000)))' $'d[0]'
1000000 loops, best of 3: 0.259 usec per loop


Not advocating writing code that doesn't protect itself- just be aware of what the code is actually doing, 
and be aware that exceptions in python code are costly due to machinery involved.

Another example is when to use or not to use dict's setdefault or get methods:

Through exception handling, key is found:
python -m timeit -s 'd=dict.fromkeys(range(100))' 'try: d[1]' 'except KeyError: 42'
1000000 loops, best of 3: 0.238 usec per loop

Through exception handling, key not found:
python -m timeit -s 'd=dict.fromkeys(range(100))' 'try: d[101]' 'except KeyError: 42'
100000 loops, best of 3: 4.73 usec per loop

d.get, key is found:
python -m timeit -s 'd=dict.fromkeys(range(100))' 'd.get(1, 42)'
1000000 loops, best of 3: 0.459 usec per loop

d.get, key is not found:
python -m timeit -s 'd=dict.fromkeys(range(100))' 'd.get(101, 42)'
1000000 loops, best of 3: 0.457 usec per loop

So if the key is usually found using [] and exceptions is faster than
using get (for the same reason "in" is faster than "has_key"). If the
key is usually not there yet get wins.

Of course this only considers the case where the default value is
simple. If it's something more costly "except" will do relatively
better since it's not constructing the default value if it's not
needed. So if in doubt and in a performance-critical piece of code:
benchmark parts of it with timeit instead of assuming "exceptions are
slow" or "[] is fast".


---------------------------
cpython sometimes 'leaks' vars into local namespace

def f(s):
	while True:
		try:
			some_func_that_throws_exception()
		except Exception, e:
			# e exists in this namespace now.
			pass
		# some other code here...

from the code above, e bled into the f namespace- that's referenced memory that isn't used, 
and will linger until the while loop exits.

Python _does_ bleed variables into the local namespace- be aware of this, and explicitly
delete references you don't need, especially dealing with exceptions.

class c:
	d = {}
	for x in range(1000):
		d[x] = x

Granted the class above is contrived, but the thing to note is that c.x is now valid-
the x from the for loop bleeds into the class namespace and stays put.

Don't leave uneeded vars lingering in class namespace.

Variables that leak from for loops _normally_ isn't an issue, just be aware it occurs- 
especially if the var is referencing a large object (thus keeping it in memory).
