#!/usr/bin/python
# Copyright: 2005 Gentoo Foundation
# Author(s): Brian Harring (ferringb@gentoo.org)
# License: GPL2
# $Id:$

import os
from pkgcore.package.atom import atom
from pkgcore.restrictions import packages, values, boolean
from pkgcore.util.currying import pre_curry

def grab_arg(arg, args):
	val = False
	try:
		while True:
			args.remove(arg)
			val = True
	except ValueError:
		pass
	return val

if __name__ == "__main__":
	import sys, pkgcore.config
	a = sys.argv[1:]
	raw = grab_arg("--raw", a)

	if "--atomstr" in a:
		def atomstr(a, l=False):
			if l:
				l = iter(a)
			else:
				l = [a]
			s = []
			for x in l:
				if isinstance(x, atom):
					s.append(x.atom_str())
				else:
					s.append(str(x))
			return ' '.join(s)
		del a[a.index("--atomstr")]
	else:
		atomstr = lambda x, y=False: str(x)

	if len(a) == 0 or "--help" in a:
		print "supported args: [--raw] [ --max || --min ] [--atomstr] [atom [ --attr attr ] ]*"
		sys.exit(1)
	conf = pkgcore.config.load_config()
	if len(conf.domain) != 1:
		print "sorry, I don't know about domains aside from using the only one I find"
		sys.exit(2)
	domain = conf.domain.items()[0][1]
	repos = []

	if raw:
		for k,r in conf.repo.iteritems():
			# hackity hack hack hack
			if not r.configured and not k.startswith("vdb"):
				repos.append(r)
	else:
		repos.extend(domain.repos)

	atoms = []
	attr = []
	while "--attr" in a:
		i = a.index("--attr")
		a.pop(i)
		try:
			attr.append(a.pop(i))
		except IndexError:
			print "need an arg to --attr!"
			sys.exit(1)

	results_filter = lambda a: a
	def less_pissy_builtins(func, *args, **kwds):
		try:
			return func(*args, **kwds)
		except ValueError:
			return []
	for s, f in (("--min", min), ("--max", max)):
		func = pre_curry(lambda inner_func,a: [inner_func(a)],
			pre_curry(less_pissy_builtins, f))
		if grab_arg(s, a):
			results_filter = func

	for x in a:
		if "*" in x:
			x = x.split("/", 1)
			if len(x) > 1:
				r = packages.AndRestriction()
				def check_glob_pos(x):
					if x.startswith("*"):
						prefix = True
					elif x.endswith("*"):
						prefix = False
					else:
						raise TypeError("'*' must be specified at the end or beginning of a matching field")
					return x.strip("*")
				if "*" in x[0]:
					x[0] = check_glob_pos(x[0])
					if len(x[0]):
						cat = values.StrGlobMatch(x[0])
					else:
						cat = None
				else:
					cat = values.StrExactMatch(x[0])
				if cat is not None:
					r.add_restriction(packages.PackageRestriction("category", cat))
				if "*" in x[1]:
					x[1] = check_glob_pos(x[1])
					if len(x[1]):
						pkg = values.StrGlobMatch(x[1])
					else:
						pkg = None
				else:
					pkg = values.StrExactMatch(x[1])
				if pkg is not None:
					r.add_restriction(packages.PackageRestriction("package", pkg))
			else:
				r = packages.PackageRestriction("package", values.StrGlobMatch(x[0]))
			atoms.append(r)
		else:
			if "/" in x:
				atoms.append(atom(x))
			else:
				if x.endswith("*"):
					atoms.append(packages.PackageRestriction("package", values.StrGlobMatch(x[:-1])))
				else:
					atoms.append(packages.PackageRestriction("package", values.StrExactMatch(x)))

	if len(atoms) > 1:
		atoms = packages.OrRestriction(*atoms)
	for a in atoms:
		for repo in repos:
			for pkg in results_filter(repo.itermatch(a)):
				try:	print str(atomstr(pkg))
				except AttributeError:
					print str(pkg)
				for x in attr:
					try:	print "attr '%s' == %s" % (x, atomstr(getattr(pkg, x), True))
					except AttributeError, ae:
						print "attr '%s' exception: %s" % (x, ae)
				print
		
	sys.exit(0)
