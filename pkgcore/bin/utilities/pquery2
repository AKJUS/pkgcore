#!/usr/bin/python
# Copyright: 2006 Marien Zwart <marienz@gentoo.org>
# License: GPL2
# Based on pquery by Brian Harring <ferringb@gmail.com>


"""Extract information from repositories."""

# TODO: --min/--max?


import sys
import optparse

from pkgcore.config import load_config
from pkgcore.util import repo_utils, commandline, lists, currying
from pkgcore.restrictions import packages, values, restriction
from pkgcore.package import atom, cpv, errors as perrors
from pkgcore.util.compatibility import any
from pkgcore import fetch
from pkgcore.ebuild import conditionals


# TODO a fair chunk of this is library code, should be moved elsewhere

class FlatteningRestriction(values.base):
	def __init__(self, dont_iter, restriction, negate=False):
		self.dont_iter = dont_iter
		self.restriction = restriction
		self.negate = negate

	def match(self, val):
		return self.restriction.match(
			lists.iflatten_instance(val, self.dont_iter)) != self.negate

	def __str__(self):
		return "flattening_restriction: iflatten_instance(val, %s), restriction: %s" % (self.dont_iter, self.restriction)

	def __repr__(self):
		return '<%s restriction=%r dont_iter=%r negate=%r @%#8x>' % (
			self.__class__.__name__,
			self.restriction, self.dont_iter, self.negate,
			id(self))

class AnyMatch(restriction.base):

	def __init__(self, restriction, negate=False, restriction_type=None):
		self.restriction, self.negate, self.type = restriction, negate, restriction_type

	def match(self, val):
		return any(self.restriction.match(x) for x in val) != self.negate

	def __str__(self):
		return "any: %s match" % self.restriction

	def __repr__(self):
		return '<%s restriction=%r @%#8x>' % (
			self.__class__.__name__, self.restriction, id(self))


class AtomIntersectsAtom(values.base):

	"""Fuzzy intersection used for the revdep match.

	Intended effect is roughly:
	- if you query for just "dev-lang/python" it "intersects" both
	  "dev-lang/python" and ">=dev-lang/python-2.4"
	- if you query for "=dev-lang/python-2.4" it "intersects"
	  ">=dev-lang/python-2.4" and "dev-lang/python" but not
	  "<dev-lang/python-2.3"

	The block/nonblock state of the atom is ignored.

	I have not figured out yet how this interacts with USE and slot deps, so
	I pretend those do not exist. Lalalala...
	"""

	def __init__(self, queryatom, negate=False):
		self.atom, self.negate = queryatom, negate

	def match(self, val):
		# If the "key" (cat/pkg) does not match we never match.
		if val.key != self.atom.key:
			return False
		# If one of us does not have a version check we always match
		if not val.op or not self.atom.op:
			return True
		# If one cpv matches the other's restriction we match
		return self.atom.match(val) or val.match(self.atom)

	def __str__(self):
		return "atom matches %s" % self.atom

	def __repr__(self):
		if self.negate:
			return '<%s atom=%r negated @%#8x>' % (
				self.__class__.__name__, self.atom, id(self))
		else:
			return '<%s atom=%r @%#8x>' % (
				self.__class__.__name__, self.atom, id(self))

ValuesAnyMatch = currying.pre_curry(
	AnyMatch, restriction_type=values.value_type)



def check_cpv(option, opt, value):
	"""optparse cpv type parser."""
	try:
		return CPV.cpv(value)
	except perrors.InvalidCPV:
		raise optparse.OptionValueError(
			'option %s: invalid cpv: %r' % (opt, value))

def check_atom(option, opt, value):
	"""optparse cpv type parser."""
	try:
		result = atom.atom(value)
	except perrors.InvalidCPV:
		raise optparse.OptionValueError(
			'option %s: invalid cpv in atom: %r' % (opt, value))
	return result

def check_restriction(option, opt, value):
	"""optparse "commandline" restriction parser."""
	try:
		return commandline.generate_restriction(value)
	except perrors.InvalidCPV:
		raise optparse.OptionValueError(
			'option %s: invalid cpv in restriction: %r' % (opt, value))

extras = {
	'cpv': check_cpv,
	'atom': check_atom,
	'restriction': check_restriction,
	}


class MyOption(optparse.Option):
	TYPES = optparse.Option.TYPES + tuple(extras.keys())
	# Copy the original dict
	TYPE_CHECKER = dict(optparse.Option.TYPE_CHECKER)
	TYPE_CHECKER.update(extras)


def build_option_parser():
	"""Construct our option parser."""
	parser = optparse.OptionParser(description=__doc__, option_class=MyOption)

	parser.add_option('--domain', action='store',
					  help='domain name to use (default used if omitted).')

	repo = parser.add_option_group('Source repo')
	repo.add_option('--raw', action='store_true',
					 help='unwrap the repos (TODO what does that mean).')
	repo.add_option('--virtuals', action='store', choices=('only', 'disable'),
					help='"only" for only matching virtuals, "disable" to not '
					'match virtuals at all. Default is to match everything.')
	repo.add_option('--vdb', action='store_true',
					help='match only vdb (installed) packages.')

	restrict = parser.add_option_group(
		'Package matching',
		'Each option specifies a restriction displayed packages must match. '
		'Specifying the same option twice means "or" unless stated otherwise. '
		'Specifying multiple types of restrictions means "and" unless stated '
		'otherwise.')
	restrict.add_option('--match', '-m', action='append', type='restriction',
						help='Glob-like match on category/package-version.')
	restrict.add_option('--hasuse', action='append',
						help='Exact string match on a USE flag.')
	restrict.add_option('--revdep', action='append', type='atom',
						help='Dependency on an atom.')
	restrict.add_option('--description', '-S', action='append',
						help='regexp match on (long)description. '
						'*exact* match, start/end with ".*" for a search.')
	restrict.add_option('--herd', action='append',
						help='exact match on a herd.')
	restrict.add_option('--license', action='append',
						help='exact match on a license.')

	output = parser.add_option_group('Output formatting')
	output.add_option('--cpv', action='store_true',
					  help='Print the category/package-version. This is done '
					  'by default, this option re-enables this if another '
					  'output option (like --contents) disabled it.')
	output.add_option('--attr', action='append',
					  choices=('rdepends', 'depends', 'post_rdepends',
							   'use', 'description', 'longdescription',
							   'herds', 'license', 'uris', 'files'),
					  help="Print this attribute's value "
					  '(can be specified more than once).')
	output.add_option('--contents', action='store_true',
					  help='list files owned by the package. Implies --vdb.')
	output.add_option('--verbose', '-v', action='store_true',
					  help='human-readable multi-line output per package')
	return parser


def stringify_attr(config, pkg, attr):
	"""Grab a package attr and convert it to a string."""
	# config is currently unused but may affect display in the future.
	if attr in ('files', 'uris'):
		data = getattr(pkg, 'fetchables', None)
		if data is None:
			return 'MISSING'
		if attr == 'files':
			def format(node):
				return node.filename
		else:
			def format(node):
				return ' '.join(node.uri or ())
		return conditionals.stringify_boolean(data, format)

	# TODO: is a missing or None attr an error?
	value = getattr(pkg, attr, None)
	if value is None:
		return 'MISSING'

	if attr in ('use', 'herds'):
		return ' '.join(value)
	return str(value)


def main(config, options):
	# Config postprocessing.
	if options.contents:
		options.vdb = True

	# Get a domain object.
	if options.domain:
		try:
			domain = config.domain[options.domain]
		except KeyError:
			print >> sys.stderr, 'domain %s not found' % (options.domain,)
			print >> sys.stderr, 'Valid domains: %s' % (
				', '.join(config.domain.keys()),)
			return 1
	else:
		domain = config.get_default('domain')
		if domain is None:
			print >> sys.stderr, (
				'No default domain found, fix your configuration '
				'or pass --domain')
			print >> sys.stderr, 'Valid domains: %s' % (
				', '.join(config.domain.keys(),))
			return 1

	# Get repo(s) to operate on
	if options.vdb:
		repos = domain.vdb
	else:
		repos = domain.repos
	if options.raw or options.virtuals:
		repos = repo_utils.get_raw_repos(repos)
	if options.virtuals:
		repos = repo_utils.get_virtual_repos(repos, options.virtuals == 'only')

	# Build up a restriction.
	# The restrictions in here will be and-ed. Ordered for speed.
	restrict = []
	if options.match:
		restrict.append(packages.OrRestriction(finalize=True, *options.match))
	if options.revdep:
		subrestrict = []
		for revdep in options.revdep:
			helper = ValuesAnyMatch(AtomIntersectsAtom(revdep))
			val_restrict = FlatteningRestriction(atom.atom, helper)
			for dep in ('depends', 'rdepends', 'post_rdepends'):
				subrestrict.append(packages.PackageRestriction(dep,
															   val_restrict))
		restrict.append(packages.OrRestriction(finalize=True, *subrestrict))
	if options.description:
		subrestrict = []
		for query in options.description:
			matcher = values.StrRegexMatch(query, CaseSensitive=False)
			for attr in ('description', 'longdescription'):
				subrestrict.append(packages.PackageRestriction(attr, matcher))
		restrict.append(packages.OrRestriction(finalize=True, *subrestrict))
	if options.herd:
		restrict.append(packages.PackageRestriction(
				'herds', values.ContainmentMatch(*options.herd)))
	if options.license:
		restrict.append(packages.PackageRestriction(
				'license', values.ContainmentMatch(*options.license)))

	if not restrict:
		# Match everything in the repo.
		restrict = packages.AlwaysTrue
	elif len(restrict) == 1:
		# Single restriction, omit the AndRestriction for a bit of speed
		restrict = restrict[0]
	else:
		# "And" them all together
		restrict = packages.AndRestriction(finalize=True, *restrict)

	# Run the query
	for repo in repos:
		try:
			for pkg in repo.itermatch(restrict, sorter=sorted):
				if options.verbose:
					print ' * %s' % (pkg.cpvstr,)
					print '     description: %s' % (pkg.description,)
					print '     homepage:    %s' % (pkg.homepage,)
					print '     license:     %s' % (pkg.license,)
					# ^%&^#@( optparse defaults to None, not an empty seq
					for attr in (options.attr or ()):
						print '     %s: %s' % (
							attr, stringify_attr(options, pkg, attr))
					print
				else:
					printedSomething = False
					if (not options.contents) or options.cpv:
						printedSomething = True
						print pkg.cpvstr,
					# hack around optparse defaulting to None
					for attr in options.attr or ():
						printedSomething = True
						print '%s="%s"' % (
							attr, stringify_attr(options, pkg, attr)),
					# If we printed anything at all print the newline now
					if printedSomething:
						print

				if options.contents:
					try:
						contents = pkg.contents
					except AttributeError:
						print >> sys.stderr, 'no contents for %r' % (pkg,)
					else:
						for thing in contents:
							print thing.location

		except KeyboardInterrupt:
			raise
		except Exception:
			print >> sys.stderr, 'caught an exception!'
			print >> sys.stderr, 'repo:', repr(repo)
			print >> sys.stderr, 'restrict:', repr(restrict)
			raise

if __name__ == '__main__':
	parser = build_option_parser()
	options, args = parser.parse_args()

	if args:
		parser.error('what do you want me to do with %s?' % (' '.join(args),))
	config = load_config()
	try:
		exitstatus = main(config, options)
	except KeyboardInterrupt:
		exitstatus = 1
	sys.exit(exitstatus)
