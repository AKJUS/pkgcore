#!/usr/bin/python
# Copyright: 2006 Marien Zwart <marienz@gentoo.org>
# License: GPL2
# Based on pquery by Brian Harring <ferringb@gmail.com>


"""Extract information from repositories."""

# TODO: --min/--max?


import sys
import optparse

from pkgcore.config import load_config
from pkgcore.util import repo_utils, commandline, lists, currying, formatters
from pkgcore.restrictions import packages, values, restriction
from pkgcore.package import atom, cpv, errors as perrors
from pkgcore.util.compatibility import any
from pkgcore import fetch
from pkgcore.ebuild import conditionals


class ParseError(ValueError):
	"""Raised if parsing a restriction expression failed."""


# Functions that turn a string into a restriction or raise ParseError.
# These are used by both the expression-parsing and the optparse code.

# To add a new restriction you have to do the following:
# - add a parse function for it here.
# - add the parse function to the parsefuncs dict.
# - add an optparse option using the name you used in the dict as typename.

def parse_match(value):
	try:
		return commandline.generate_restriction(value)
	except perrors.InvalidCPV:
		raise ParseError('invalid cpv')

def parse_revdep(value):
	val_restrict = FlatteningRestriction(
		atom.atom, ValuesAnyMatch(AtomIntersectsAtom(revdep)))
	return packages.OrRestriction(finalize=True, *list(
			packages.PackageRestriction(dep, val_restrict)
			for dep in ('depends', 'rdepends', 'post_rdepends')))

def parse_description(value):
	matcher = values.StrRegexMatch(value, CaseSensitive=False)
	return packages.OrRestriction(finalize=True, *list(
			packages.PackageRestriction(attr, matcher)
			for attr in ('description', 'longdescription')))

def commaSeparatedContainment(attr):
	"""Helper for parsing comma-separated strings to a ContainmentMatch."""
	def _parse(value):
		return packages.PackageRestriction(attr, values.ContainmentMatch(*(
					piece.strip() for piece in value.split(','))))
	return _parse

def parse_herd(value):
	return packages.PackageRestriction('herds', values.ContainmentMatch(*(
				herd.strip() for herd in value.split(','))))

def parse_license(value):
	return packages.PackageRestriction('license', values.ContainmentMatch(*(
				license.strip() for license in value.split(','))))

parsefuncs = {
	'match': parse_match,
	'revdep': parse_revdep,
	'description': parse_description,
	'herd': commaSeparatedContainment('herds'),
	'license': commaSeparatedContainment('license'),
	}


try:
	import pyparsing as pyp
except ImportError:
	def parseExpression(string):
		raise ParseError('pyparsing is not installed.')
else:
	string = pyp.quotedString.setParseAction(pyp.removeQuotes)
	string |= pyp.Word(pyp.alphanums + ',')

	def funcall(name, parser):
		result = pyp.Suppress('%s(' % (name,)) + string + pyp.Suppress(')')
		def _parse(tokens):
			return parser(tokens[0])
		result.setParseAction(_parse)
		return result

	boolcall = pyp.Forward()
	expr = boolcall
	for name, func in parsefuncs.iteritems():
		expr |= funcall(name, func)

	andcall = (pyp.Suppress(pyp.CaselessLiteral('and') + '(') +
			   pyp.delimitedList(expr) + pyp.Suppress(')'))
	def parse_and(tokens):
		return packages.AndRestriction(*tokens)
	andcall.setParseAction(parse_and)

	orcall = (pyp.Suppress(pyp.CaselessLiteral('or') + '(') +
			   pyp.delimitedList(expr) + pyp.Suppress(')'))
	def parse_or(tokens):
		return packages.OrRestriction(*tokens)
	orcall.setParseAction(parse_or)

	notcall = (pyp.Suppress(pyp.CaselessLiteral('not') + '(') + expr +
			   pyp.Suppress(')'))
	def parse_not(tokens):
		restriction = tokens[0]
		restriction.negate = not restriction.negate
		return restriction
	notcall.setParseAction(parse_not)

	boolcall << (notcall | andcall | orcall)

	# This forces a match on the entire thing, without it trailing
	# unparsed data is ignored.
	grammar = pyp.stringStart + expr + pyp.stringEnd

	# grammar.validate()

	def parseExpression(string):
		try:
			return grammar.parseString(string)[0]
		except pyp.ParseException, e:
			raise ParseError(e.msg)



# TODO a fair chunk of this is library code, should be moved elsewhere

class FlatteningRestriction(values.base):
	def __init__(self, dont_iter, restriction, negate=False):
		self.dont_iter = dont_iter
		self.restriction = restriction
		self.negate = negate

	def match(self, val):
		return self.restriction.match(
			lists.iflatten_instance(val, self.dont_iter)) != self.negate

	def __str__(self):
		return "flattening_restriction: iflatten_instance(val, %s), restriction: %s" % (self.dont_iter, self.restriction)

	def __repr__(self):
		return '<%s restriction=%r dont_iter=%r negate=%r @%#8x>' % (
			self.__class__.__name__,
			self.restriction, self.dont_iter, self.negate,
			id(self))

class AnyMatch(restriction.base):

	def __init__(self, restriction, negate=False, restriction_type=None):
		self.restriction, self.negate, self.type = restriction, negate, restriction_type

	def match(self, val):
		return any(self.restriction.match(x) for x in val) != self.negate

	def __str__(self):
		return "any: %s match" % self.restriction

	def __repr__(self):
		return '<%s restriction=%r @%#8x>' % (
			self.__class__.__name__, self.restriction, id(self))


class AtomIntersectsAtom(values.base):

	"""Fuzzy intersection used for the revdep match.

	Intended effect is roughly:
	- if you query for just "dev-lang/python" it "intersects" both
	  "dev-lang/python" and ">=dev-lang/python-2.4"
	- if you query for "=dev-lang/python-2.4" it "intersects"
	  ">=dev-lang/python-2.4" and "dev-lang/python" but not
	  "<dev-lang/python-2.3"

	The block/nonblock state of the atom is ignored.

	I have not figured out yet how this interacts with USE and slot deps, so
	I pretend those do not exist. Lalalala...
	"""

	def __init__(self, queryatom, negate=False):
		self.atom, self.negate = queryatom, negate

	def match(self, val):
		# If the "key" (cat/pkg) does not match we never match.
		if val.key != self.atom.key:
			return False
		# If one of us does not have a version check we always match
		if not val.op or not self.atom.op:
			return True
		# If one cpv matches the other's restriction we match
		return self.atom.match(val) or val.match(self.atom)

	def __str__(self):
		return "atom matches %s" % self.atom

	def __repr__(self):
		if self.negate:
			return '<%s atom=%r negated @%#8x>' % (
				self.__class__.__name__, self.atom, id(self))
		else:
			return '<%s atom=%r @%#8x>' % (
				self.__class__.__name__, self.atom, id(self))

ValuesAnyMatch = currying.pre_curry(
	AnyMatch, restriction_type=values.value_type)


def optparse_type(parsefunc):
	"""Wrap a parsefunc shared with the expression-style code for optparse."""
	def _typecheck(option, opt, value):
		try:
			return parsefunc(value)
		except ParseError, e:
			raise optparse.OptionValueError('option %s: %s' % (opt, e))
	return _typecheck


extras = dict((name, optparse_type(func))
			  for name, func in parsefuncs.iteritems())

class MyOption(optparse.Option):
	TYPES = optparse.Option.TYPES + tuple(extras.keys())
	# Copy the original dict
	TYPE_CHECKER = dict(optparse.Option.TYPE_CHECKER)
	TYPE_CHECKER.update(extras)


def build_option_parser():
	"""Construct our option parser."""
	parser = optparse.OptionParser(description=__doc__, option_class=MyOption)

	parser.add_option('--domain', action='store',
					  help='domain name to use (default used if omitted).')

	repo = parser.add_option_group('Source repo')
	repo.add_option('--raw', action='store_true',
					 help='unwrap the repos (TODO what does that mean).')
	repo.add_option('--virtuals', action='store', choices=('only', 'disable'),
					help='"only" for only matching virtuals, "disable" to not '
					'match virtuals at all. Default is to match everything.')
	repo.add_option('--vdb', action='store_true',
					help='match only vdb (installed) packages.')

	restrict = parser.add_option_group(
		'Package matching',
		'Each option specifies a restriction displayed packages must match. '
		'Specifying the same option twice means "or" unless stated otherwise. '
		'Specifying multiple types of restrictions means "and" unless stated '
		'otherwise.')
	restrict.add_option('--match', '-m', action='append', type='match',
						help='Glob-like match on category/package-version.')
	restrict.add_option('--hasuse', action='append',
						help='Exact string match on a USE flag.')
	restrict.add_option('--revdep', action='append', type='revdep',
						help='Dependency on an atom.')
	restrict.add_option('--description', '-S', action='append',
						type='description',
						help='regexp match on (long)description. '
						'*exact* match, start/end with ".*" for a search.')
	restrict.add_option('--herd', action='append', type='herd',
						help='exact match on a herd.')
	restrict.add_option('--license', action='append',
						help='exact match on a license.')

	output = parser.add_option_group('Output formatting')
	output.add_option('--cpv', action='store_true',
					  help='Print the category/package-version. This is done '
					  'by default, this option re-enables this if another '
					  'output option (like --contents) disabled it.')
	output.add_option('--attr', action='append',
					  choices=('rdepends', 'depends', 'post_rdepends',
							   'use', 'description', 'longdescription',
							   'herds', 'license', 'uris', 'files'),
					  help="Print this attribute's value "
					  '(can be specified more than once).')
	output.add_option('--contents', action='store_true',
					  help='list files owned by the package. Implies --vdb.')
	output.add_option('--verbose', '-v', action='store_true',
					  help='human-readable multi-line output per package')
	return parser


def stringify_attr(config, pkg, attr):
	"""Grab a package attr and convert it to a string."""
	# config is currently unused but may affect display in the future.
	if attr in ('files', 'uris'):
		data = getattr(pkg, 'fetchables', None)
		if data is None:
			return 'MISSING'
		if attr == 'files':
			def format(node):
				return node.filename
		else:
			def format(node):
				return ' '.join(node.uri or ())
		return conditionals.stringify_boolean(data, format)

	# TODO: is a missing or None attr an error?
	value = getattr(pkg, attr, None)
	if value is None:
		return 'MISSING'

	if attr in ('use', 'herds'):
		return ' '.join(value)
	return str(value)


def main(config, options, args):
	# Config postprocessing.
	if options.contents:
		options.vdb = True

	# Get a domain object.
	if options.domain:
		try:
			domain = config.domain[options.domain]
		except KeyError:
			print >> sys.stderr, 'domain %s not found' % (options.domain,)
			print >> sys.stderr, 'Valid domains: %s' % (
				', '.join(config.domain.keys()),)
			return 1
	else:
		domain = config.get_default('domain')
		if domain is None:
			print >> sys.stderr, (
				'No default domain found, fix your configuration '
				'or pass --domain')
			print >> sys.stderr, 'Valid domains: %s' % (
				', '.join(config.domain.keys(),))
			return 1

	# Get repo(s) to operate on
	if options.vdb:
		repos = domain.vdb
	else:
		repos = domain.repos
	if options.raw or options.virtuals:
		repos = repo_utils.get_raw_repos(repos)
	if options.virtuals:
		repos = repo_utils.get_virtual_repos(repos, options.virtuals == 'only')

	# Build up a restriction.
	restrict = []
	for attr in (options.match, options.revdep, options.description,
				 options.herd, options.license):
		if attr:
			restrict.append(packages.OrRestriction(finalize=True, *attr))

	if args:
		expr = ' '.join(args)
		try:
			restrict.append(parseExpression(expr))
		except ParseError, e:
			print >> sys.stderr, 'failure parsing "%s": %s' % (expr, e)
			return 1

	if not restrict:
		# Match everything in the repo.
		restrict = packages.AlwaysTrue
	elif len(restrict) == 1:
		# Single restriction, omit the AndRestriction for a bit of speed
		restrict = restrict[0]
	else:
		# "And" them all together
		restrict = packages.AndRestriction(finalize=True, *restrict)

	# Get a pretty-printer if we need one
	if options.verbose:
		f = formatters.TerminfoFormatter()

	# Run the query
	for repo in repos:
		try:
			for pkg in repo.itermatch(restrict, sorter=sorted):
				if options.verbose:
					green = f.fg('green')
					f.write(f.bold, green, ' * ', f.fg(), pkg.cpvstr)
					f.write(green, '     description: ',
							f.fg(), pkg.description)
					f.write(green, '     homepage:    ', f.fg(), pkg.homepage)
					f.write(green, '     license:     ', f.fg(), pkg.license)
					# ^%&^#@( optparse defaults to None, not an empty seq
					for attr in (options.attr or ()):
						f.write(green, '     %s: ' % (attr,), f.fg(),
								stringify_attr(options, pkg, attr))
					f.write()
				else:
					printedSomething = False
					if (not options.contents) or options.cpv:
						printedSomething = True
						print pkg.cpvstr,
					# hack around optparse defaulting to None
					for attr in options.attr or ():
						printedSomething = True
						print '%s="%s"' % (
							attr, stringify_attr(options, pkg, attr)),
					# If we printed anything at all print the newline now
					if printedSomething:
						print

				if options.contents:
					try:
						contents = pkg.contents
					except AttributeError:
						print >> sys.stderr, 'no contents for %r' % (pkg,)
					else:
						for thing in contents:
							print thing.location

		except KeyboardInterrupt:
			raise
		except Exception:
			print >> sys.stderr, 'caught an exception!'
			print >> sys.stderr, 'repo:', repr(repo)
			print >> sys.stderr, 'restrict:', repr(restrict)
			raise

if __name__ == '__main__':
	parser = build_option_parser()
	options, args = parser.parse_args()
	config = load_config()
	try:
		exitstatus = main(config, options, args)
	except KeyboardInterrupt:
		exitstatus = 1
	sys.exit(exitstatus)
