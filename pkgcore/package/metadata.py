# Copyright: 2005 Brian Harring <ferringb@gmail.com>
# License: GPL2


"""
package with it's metadata accessible (think 'no longer abstract')
"""

import weakref
import warnings

from cpv import CPV
from pkgcore.package.atom import atom

class package(CPV):

	__doc__ = "package class with metadata bound to it for attribute generation\n\n" + \
		"\n".join(x.lstrip() for x in CPV.__doc__.split("\n") if "@ivar" in x or "@cvar" in x)
	__doc__+="\n@ivar repo: parent repository"
	immutable = True
	package_is_real = True

	_get_attr = dict(CPV._get_attr)

	def __init__(self, cpv, parent_repository):
		"""
		@param cpv: cpv string to parse.  Gentoo specific, should be abstracted out
		@param parent_repository: parent repository this package belongs to
		@type parent_repository: L{pkgcore.repository.prototype.tree} instance
		"""
		super(package, self).__init__(cpv)
		self.__dict__["_parent"] = parent_repository


	def __setattr__(self, *args, **kwargs):
		raise AttributeError


	def __delattr__(self, *args, **kwargs):
		raise AttributeError


	def __getitem__(self, key):
		try:	return getattr(self, key)
		except AttributeError:
			raise KeyError(key)

	def _get_data(self):
		"""internal hook func to get the packages metadata, consumer of L{_get_attr}"""
		if "data" in self.__dict__:
			warnings.warn("odd, got a request for data yet it's in the dict")
			return self.__dict__["data"]

		return self._fetch_metadata()
	_get_attr["data"] = _get_data

	@property
	def repo(self):
		return self._parent._parent_repo

	@property
	def slotted_atom(self):
		return atom("%s:%s" % (self.key, self.slot))

	def _fetch_metadata(self):
		"""
		pull the metadata for this package.
		must be overrode in derivative
		"""
		raise NotImplementedError


class factory(object):

	"""
	package generator
	
	does weakref caching per repository

	@cvar child_class: callable to generate packages
	"""

	child_class = package

	def __init__(self, parent_repo):
		self._parent_repo = parent_repo
		self._cached_instances = weakref.WeakValueDictionary()

	def new_package(self, cpv):
		"""
		generate a new package instance
		
		@param cpv: cpvstring to parse for the new package (gentoo specific, abstract this out)
		@type cpv: string
		"""
		
		if cpv in self._cached_instances:
			return self._cached_instances[cpv]
		d = self._get_new_child_data(cpv)
		m = self.child_class(cpv, self, *d[0], **d[1])
		self._cached_instances[cpv] = m
		return m

	def clear(self):
		"""
		wipe the weakref cache of packages instances
		"""
		self._cached_instances.clear()

	def _get_metadata(self, *args):
		"""must be overriden in derivatives, pulls metadata from the repo/cache/wherever"""
		raise NotImplementedError

	def _update_metadata(self, *args):
		"""must be overriden in derivatives, updates metadata in the repo/cache/wherever"""
		raise NotImplementedError

	def _get_new_child_data(self, cpv):
		"""return pargs,kwargs for any new children generated by this factory.
		defaults to [], {}
		Probably will be rolled into a class/instance attribute whenever someone cleans this up"""
		return ([], {})


class MetadataException(Exception):

	def __init__(self, pkg, attr, error):
		self.pkg, self.attr, self.error = pkg, attr, error
	
	def __str__(self):
		return "Metadata Exception: pkg %s, attr %s\nerror: %s" % (self.pkg, self.attr, self.error)
