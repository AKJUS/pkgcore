#!/bin/bash
# ebuild-default-functions.sh; default functions for ebuild env that aren't saved- specific to the portage instance.
# Copyright 2005-2011 Brian Harring <ferringb@gmail.com>: BSD/GPL2
# Copyright 2004-2006 Gentoo Foundation: GPL2

portageq() {
	if [[ $EBUILD_PHASE == depend ]]; then
		die "portageq calls in depends phase aren't allowed"
	fi
	local command="$1"
	shift
	# suppress sandbox for the invocation; do this to avoid things like .pyc generation
	# being snagged by the sandbox
	local portageq_str=portageq
	${PKGCORE_DISABLE_COMPAT-false} && portageq_str=query
	SANDBOX_on=0 PYTHONPATH="$PKGCORE_PYTHONPATH" "${PKGCORE_PYTHON_BINARY}" \
		"${PKGCORE_BIN_PATH}/pinspect" ${portageq_str} "${command}" \
			--eapi "${EAPI:--1}" --use "${USE}" "$@"
	local ret="$?"
	[[ "$ret" == 127 ]] && die "pinspect couldn't be found; broken pkgcore installation?"
	return $(( $ret ))
}

has_version()
{
	PKGCORE_DISABLE_COMPAT=true portageq 'has_version' "$1"
}

best_version()
{
	PKGCORE_DISABLE_COMPAT=true portageq 'best_version' "$1"
}

# adds ".keep" files so that dirs aren't auto-cleaned
keepdir()
{
	${PKGCORE_PREFIX_SUPPORT} || local ED="${D}"
	dodir "$@"
	if [[ "$1" == "-R" ]] || [[ "$1" == "-r" ]]; then
		shift
		find "$@" -type d -printf "${ED}/%p/.keep\0" | $XARGS -0 -n100 touch || die "Failed to recursive create .keep files"
	else
		local x
		for x in "$@"; do
			touch "${ED}/${x}/.keep" || die "Failed to create .keep in ${ED}/${x}"
		done
	fi
}

# sandbox support functions
addread()
{
	export SANDBOX_READ="$SANDBOX_READ:$1"
}

addwrite()
{
	export SANDBOX_WRITE="$SANDBOX_WRITE:$1"
}

adddeny()
{
	export SANDBOX_DENY="$SANDBOX_DENY:$1"
}

addpredict()
{
	export SANDBOX_PREDICT="$SANDBOX_PREDICT:$1"
}

unpack()
{
	local x y myfail srcdir taropts tar_subdir name
	taropts='--no-same-owner'

	[[ "$#" == 0 ]] && die "Nothing passed to the 'unpack' command"

	for x in "$@"; do
		echo ">>> Unpacking ${x} to ${PWD}"
		myfail="failure unpacking ${x}"
		y="${x%.*}"
		y="${y##*.}"
		if [[ "${x:0:2}" == "./" ]]; then
			srcdir=''
		else
			srcdir="${DISTDIR}"
		fi

		[[ ! -e "${srcdir}${x}" ]] && die "$myfail: file doesn't exist"
		[[ ! -s "${srcdir}${x}" ]] && die "$myfail: empty file"
		[[ "${x/${DISTDIR}}" != "${x}" ]] && \
			die "Arguments to unpack() should not begin with \${DISTDIR}."

		name="${x##*/}"

		case "${x}" in
			*.tar)
				tar xf "${srcdir}${x}" ${taropts} || die "$myfail"
				;;
			*.tar.gz|*.tgz|*.tar.Z)
				tar xzf "${srcdir}${x}" ${taropts} || die "$myfail"
				;;
			*.tar.bz2|*.tbz2|*.tbz)
				bzip2 -dc "${srcdir}${x}" | tar xf - ${taropts}
				assert "$myfail"
				;;
			*.tar.xz)
				if has "$EAPI" 0 1 2; then
					echo "xv is a supported extension in eapi3 and above only" >&2
					continue;
				fi
				xz -dc "${srcdir}${x}" | tar xf - ${taropts} || die "$myfail"
				;;
			*.ZIP|*.zip|*.jar)
				{ set +x; while :; do echo n || break; done } | \
					unzip -qo "${srcdir}${x}" || die "$myfail"
				;;
			*.gz|*.Z|*.z)
				gzip -dc "${srcdir}${x}" > ${name%.*} || die "$myfail"
				;;
			*.bz2|*.bz)
				bzip2 -dc "${srcdir}${x}" > ${name%.*} || die "$myfail"
				;;
			*.xz)
				if has "$EAPI" 0 1 2; then
					echo "xv is a supported extension in eapi3 and above only" >&2
					continue;
				fi
				xz -dc "${srcdir}${x}" > ${name%.*} || die "$myfail"
				;;
			*.7Z|*.7z)
				local my_output
				my_output="$(7z x -y "${srcdir}/${x}")"
				if [[ $? -ne 0 ]]; then
					echo "${my_output}" >&2
					die "$myfail"
				fi
				;;
			*.RAR|*.rar)
				unrar x -idq -o+ "${srcdir}/${x}" || die "$myfail"
				;;
			*.LHa|*.LHA|*.lha|*.lzh)
				lha xfq "${srcdir}/${x}" || die "$myfail"
				;;
			*.a|*.deb)
				ar x "${srcdir}/${x}" || die "$myfail"
				;;
			*.lzma)
				if [[ "${y}" == "tar" ]]; then
					lzma -dc "${srcdir}${x}" | tar xof - ${taropts}
					assert "$myfail"
				else
					lzma -dc "${srcdir}${x}" > ${name%.*} || die "$myfail"
				fi
				;;
			*)
				echo "unpack ${x}: file format not recognized. Ignoring."
				;;
		esac
	done
	find . -mindepth 1 -maxdepth 1 ! -type l -print0 | \
		 ${XARGS} -0 chmod -fR a+rX,u+w,g-w,o-w

}

dyn_src_install()
{
	local f
	echo
	if ${PKGCORE_PREFIX_SUPPORT}; then
		echo ">>> Install ${PF} into ${ED} category ${CATEGORY}"
	else
		echo ">>> Install ${PF} into ${D} category ${CATEGORY}"
	fi
	if is_function src_install; then
		qa_invoke src_install
	else
		qa_run_function_if_exists pkgcore_default_src_install
	fi

	"${PKGCORE_BIN_PATH}/helpers/internals/prepall"
	${PKGCORE_PREFIX_SUPPORT} || local ED="${D}"
	cd "${ED}"

	if type -p scanelf > /dev/null ; then
		# Make sure we disallow insecure RUNPATH/RPATH's
		# Don't want paths that point to the tree where the package was built
		# (older, broken libtools would do this).  Also check for null paths
		# because the loader will search $PWD when it finds null paths.
		f=$(scanelf -qyRF '%r %p' "${ED}" | grep -E "(${WORKDIR}|${ED}|: |::|^ )")
		if [[ -n ${f} ]] ; then
			echo -ne '\a\n'
			echo "QA Notice: the following files contain insecure RUNPATH's"
			echo " Please file a bug about this at http://bugs.gentoo.org/"
			echo " For more information on this issue, kindly review:"
			echo " http://bugs.gentoo.org/81745"
			echo "${f}"
			echo -ne '\a\n'
			has stricter $FEATURES && die "Insecure binaries detected"
			echo "autofixing rpath..."
			TMPDIR="${WORKDIR}" scanelf -BXr ${f} -o /dev/null
		fi

		# Check for setid binaries but are not built with BIND_NOW
		f=$(scanelf -qyRF '%b %p' "${ED}")
		if [[ -n ${f} ]] ; then
			echo -ne '\a\n'
			echo "QA Notice: the following files are setXid, dyn linked, and using lazy bindings"
			echo " This combination is generally discouraged.  Try forcing via bashrc"
			echo " LDFLAGS='-Wl,-z,now' for the pkg, or disable FEATURES=stricter"
			echo "${f}"
			echo -ne '\a\n'
			has stricter $FEATURES && die "Aborting due to lazy bindings"
			sleep 1
		fi

		# TEXTREL's are baaaaaaaad
		f=$(scanelf -qyRF '%t %p' "${ED}")
		if [[ -n ${f} ]] ; then
			echo -ne '\a\n'
			echo "QA Notice: the following files contain runtime text relocations"
			echo " Text relocations require a lot of extra work to be preformed by the"
			echo " dynamic linker which will cause serious performance impact on IA-32"
			echo " and might not function properly on other architectures hppa for example."
			echo " If you are a programmer please take a closer look at this package and"
			echo " consider writing a patch which addresses this problem."
			echo "${f}"
			echo -ne '\a\n'
			has stricter $FEATURES && die "Aborting due to textrels"
			sleep 1
		fi

		# Check for files with executable stacks
		f=$(scanelf -qyRF '%e %p' "${ED}")
		if [[ -n ${f} ]] ; then
			echo -ne '\a\n'
			echo "QA Notice: the following files contain executable stacks"
			echo " Files with executable stacks will not work properly (or at all!)"
			echo " on some architectures/operating systems.  A bug should be filed"
			echo " at http://bugs.gentoo.org/ to make sure the file is fixed."
			echo "${f}"
			echo -ne '\a\n'
			has stricter $FEATURES && die "Aborting due to +x stack"
			sleep 1
		fi

		# disabled by harring; we don't use it currently.
		# Save NEEDED information
		#scanelf -qyRF '%p %n' "${ED}" | sed -e 's:^:/:' > "${T}/NEEDED"
	fi

	echo ">>> Completed installing ${PF} into ${ED}"
	echo
	unset dir
}

dyn_pkg_preinst()
{
	local i

	if is_function pkg_preinst; then
		qa_invoke pkg_preinst
	else
		qa_run_function_if_exists pkgcore_default_pkg_preinst
	fi

	${PKGCORE_PREFIX_SUPPORT} || local ED="${D}"

	# total suid control.
	if has suidctl $FEATURES > /dev/null ; then
		sfconf=/etc/portage/suidctl.conf
		echo ">>> Preforming suid scan in ${ED}"
		for i in $(find "${ED}"/ -type f \( -perm -4000 -o -perm -2000 \) ); do
			if [[ -s "${sfconf}" ]]; then
				suid=$(grep ^${i/${ED}/}$ ${sfconf})
				if [[ "${suid}" = "${i/${ED}/}" ]]; then
					echo "- ${i/${ED}/} is an approved suid file"
				else
					echo ">>> Removing sbit on non registered ${i/${ED}/}"
					chmod ugo-s "${i}"
					grep ^#${i/${ED}/}$ ${sfconf} > /dev/null || {
						# sandbox prevents us from writing directly
						# to files outside of the sandbox, but this
						# can easly be bypassed using the addwrite() function
						addwrite "${sfconf}"
						echo ">>> Appending commented out entry to ${sfconf} for ${PF}"
						ls_ret=`ls -ldh "${i}"`
						echo "## ${ls_ret%${ED}*}${ls_ret#*${ED}}" >> ${sfconf}
						echo "#${i/${ED}/}" >> ${sfconf}
						# no delwrite() eh?
						# delwrite ${sconf}
					}
				fi
			else
				echo "suidctl feature set but you are lacking a ${sfconf}"
			fi
		done
	fi

	# SELinux file labeling (needs to always be last in dyn_preinst)
	if has selinux $FEATURES || use selinux; then
		# only attempt to label if setfiles is executable
		# and 'context' is available on selinuxfs.
		if [[ -f /selinux/context ]] && [[ -x /usr/sbin/setfiles ]]; then
			echo ">>> Setting SELinux security labels"
			if [[ -f ${POLICYDIR}/file_contexts/file_contexts ]]; then
				cp -f "${POLICYDIR}/file_contexts/file_contexts" "${T}"
			else
				make -C "${POLICYDIR}" FC=${T}/file_contexts "${T}/file_contexts"
			fi

			addwrite /selinux/context
			/usr/sbin/setfiles -r "${ED}" "${T}/file_contexts" "${ED}" \
				|| die "Failed to set SELinux security labels."
		else
			# nonfatal, since merging can happen outside a SE kernel
			# like during a recovery situation
			echo "!!! Unable to set SELinux security labels"
		fi
	fi
}

pkgcore_internal_inherit()
{
	# default, backwards compatible beast.
	local location overlay
	location="${ECLASSDIR}/${1}.eclass"

	if [[ -n "$PORTDIR_OVERLAY" ]]; then
		local overlay
		for overlay in ${PORTDIR_OVERLAY}; do
			if [[ -e "${overlay}/eclass/${1}.eclass" ]]; then
				location="${overlay}/eclass/${1}.eclass"
				debug-print "  eclass exists: ${location}"
			fi
		done
	fi
	debug-print "inherit: $1 -> $location"
	qa_invoke source "$location" >&2 || die "died sourcing $location in inherit()"
	return 0
}

inherit()
{
	local ECLASS_DEPTH=$(( ${ECLASS_DEPTH-0} + 1 ))

	if [[ $ECLASS_DEPTH > 1 ]]; then
		debug-print "*** Multiple Inheritence (Level: ${ECLASS_DEPTH})"
	fi

	local location olocation
	local ECLASS

	# note that this ensures any later unsets/mangling, the ebuilds original
	# setting is protected.
	local IUSE REQUIRED_USE DEPEND RDEPEND PDEPEND

    for ECLASS in "$@"; do

		if [[ "$EBUILD_PHASE" != "depend" ]]; then
			if ! has $ECLASS $INHERITED; then
				echo
				echo "QA Notice: ECLASS '$ECLASS' illegal conditional inherit in $CATEGORY/$PF" >&2
				echo
			fi
		fi

		unset IUSE REQUIRED_USE DEPEND RDEPEND PDEPEND

		pkgcore_internal_inherit "$1" || die "failed sourcing $1 in inherit()"

		# If each var has a value, append it to the global variable E_* to
		# be applied after everything is finished. New incremental behavior.
		[[ -n "${IUSE}"         ]] && E_IUSE+="${E_IUSE:+ }${IUSE}"
		[[ -n "${REQUIRED_USE}" ]] && E_REQUIRED_USE+="${E_REQUIRED_USE:+ }${REQUIRED_USE}"
		[[ -n "${DEPEND}"       ]] && E_DEPEND+="${E_DEPEND:+ }${DEPEND}"
		[[ -n "${RDEPEND}"      ]] && E_RDEPEND+="${E_RDEPEND:+ }${RDEPEND}"
		[[ -n "${PDEPEND}"      ]] && E_PDEPEND+="${E_PDEPEND:+ }${PDEPEND}"

		# while other PMs do has checks to keep this unique, we don't; no need,
		# further up the stack (python side) we uniquify this.
		# if you try to do it in bash rather than python, it's ~10% slower regen
		INHERITED="${INHERITED} $ECLASS"

		shift
	done
}

# Exports stub functions that call the eclass's functions, thereby making them default.
# For example, if ECLASS="base" and you call "EXPORT_FUNCTIONS src_unpack", the following
# code will be eval'd:
# src_unpack() { base_src_unpack; }
EXPORT_FUNCTIONS()
{
	if [[ -z "$ECLASS" ]]; then
		echo "EXPORT_FUNCTIONS without a defined ECLASS" >&2
		exit 1
	fi
	while [[ -n "$1" ]]; do
		debug-print "EXPORT_FUNCTIONS: ${1} -> ${ECLASS}_${1}"
		eval "$1() { ${ECLASS}_$1 "\$@" ; }" > /dev/null
		shift
	done
}

QA_INTERCEPTORS="javac java-config python python-config perl grep egrep fgrep sed gcc g++ cc bash awk nawk pkg-config"
enable_qa_interceptors()
{
	# Turn of extended glob matching so that g++ doesn't get incorrectly matched.
	shopt -u extglob

	# QA INTERCEPTORS
	local FUNC_SRC BIN BODY BIN_PATH
	for BIN in ${QA_INTERCEPTORS}; do
		BIN_PATH=$(type -pf ${BIN})
		if [[ "$?" != "0" ]]; then
			BODY="echo \"*** missing command: ${BIN}\" >&2; return 127"
		else
			BODY="${BIN_PATH} \"\$@\"; return \$?"
		fi
		FUNC_SRC="function ${BIN}() {
			echo -n \"QA Notice: ${BIN} in global scope: \" >&2
			if [[ \$ECLASS_DEPTH -gt 0 ]]; then
				echo \"eclass \${ECLASS}\" >&2
			else
				echo \"\${CATEGORY}/\${PF}\" >&2
			fi
			${BODY}
		}";
		eval "$FUNC_SRC" || echo "error creating QA interceptor ${BIN}" >&2
	done
}

disable_qa_interceptors()
{
	local x
	for x in $QA_INTERCEPTORS; do
		unset -f $x
	done
}

useq()
{
	local u="${1}"
	local neg=0
	if [[ "${u:0:1}" == "!" ]]; then
		u="${u:1}"
		neg=1
	fi

	# Make sure we have this USE flag in IUSE
	# temp disable due to PORTAGE_ARCHLIST not being exported in
	#if ! has "${u}" ${IUSE} ${E_IUSE} && ! has "${u}" ${PORTAGE_ARCHLIST} selinux; then
	#    echo "QA Notice: USE Flag '${u}' not in IUSE for ${CATEGORY}/${PF}" >&2
	#fi

	local x
	for x in ${USE}; do
		if [[ "${x}" == "${u}" ]]; then
			if [[ ${neg} -eq 1 ]]; then
				return 1
			else
				return 0
			fi
		fi
	done
	if [[ ${neg} -eq 1 ]]; then
		return 0
	else
		return 1
	fi
}

usev()
{
	if useq ${1}; then
		echo "${1}"
		return 0
	fi
	return 1
}

insopts()
{
	local x
	INSOPTIONS=""
	for x in $*; do
		#if we have a debug build, let's not strip anything
		if has nostrip $FEATURES $RESTRICT && [[ "$x" == "-s" ]]; then
			continue
		else
			INSOPTIONS="$INSOPTIONS $x"
		fi
	done
	export INSOPTIONS
}

diropts()
{
	local x
	DIROPTIONS=""
	for x in $*; do
		DIROPTIONS="${DIROPTIONS} $x"
	done
	export DIROPTIONS
}

exeopts()
{
	local x
	EXEOPTIONS=""
	for x in $*; do
		#if we have a debug build, let's not strip anything
		if has nostrip $FEATURES $RESTRICT && [[ "$x" == "-s" ]]; then
			continue
		else
			EXEOPTIONS="$EXEOPTIONS $x"
		fi
	done
	export EXEOPTIONS
}

libopts()
{
	local x
	LIBOPTIONS=""
	for x in $*; do
		#if we have a debug build, let's not strip anything
		if has nostrip $FEATURES $RESTRICT && [[ "$x" == "-s" ]]; then
			continue
		else
			LIBOPTIONS="$LIBOPTIONS $x"
		fi
	done
	export LIBOPTIONS
}

DONT_EXPORT_VARS="${DONT_EXPORT_VARS} ECLASS_DEPTH"

:
