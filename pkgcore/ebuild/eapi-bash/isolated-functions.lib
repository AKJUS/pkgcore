# Copyright 2006-2011 Brian Harring <ferringb@gmail.com>
# License GPL2/BSD3

# Internal logging function, don't use this in ebuilds
pkgcore_elog_base() {
	local messagetype
	[ -z "${1}" -o -z "${T}" -o ! -d "${T}/logging" ] && return 1
	case "${1}" in
		INFO|WARN|ERROR|LOG)
			messagetype="${1}"
			shift
			;;
		*)
			echo -e " ${PKGCORE_RC_BAD}*${PKGCORE_RC_NORMAL} Invalid use of internal function pkgcore_elog_base(), next message will not be logged" >&2
			return 1
			;;
	esac
	echo "$*" >> ${T}/logging/${EBUILD_PHASE}.${messagetype}
	return 0
}

unset_colors() {
	PKGCORE_RC_COLS="25 80"
	PKGCORE_RC_ENDCOL=
	PKGCORE_RC_GOOD=
	PKGCORE_RC_WARN=
	PKGCORE_RC_BAD=
	PKGCORE_RC_NORMAL=
	PKGCORE_RC_HILITE=
	PKGCORE_RC_BRACKET=
}

set_colors() {
	# try setting the column width to bash's internal COLUMNS variable,
	# then try to get it via stty.  no go? hardcode it to 80.
	PKGCORE_RC_COLS=${COLUMNS:-0}
	(( PKGCORE_RC_COLS == 0 )) && PKGCORE_RC_COLS=$(set -- `stty size 2>/dev/null` ; echo $2)
	(( PKGCORE_RC_COLS > 0 )) || (( PKGCORE_RC_COLS = 80 ))
	PKGCORE_RC_COLS=$((${PKGCORE_RC_COLS} - 8))	# width of [ ok ] == 7

	PKGCORE_RC_ENDCOL=$'\e[A\e['${PKGCORE_RC_COLS}'C'
	# Now, ${PKGCORE_RC_ENDCOL} will move us to the end of the
	# column;  irregardless of character width

	PKGCORE_RC_GOOD=$'\e[32;01m'
	PKGCORE_RC_WARN=$'\e[33;01m'
	PKGCORE_RC_BAD=$'\e[31;01m'
	PKGCORE_RC_HILITE=$'\e[36;01m'
	PKGCORE_RC_BRACKET=$'\e[34;01m'
	PKGCORE_RC_NORMAL=$'\e[0m'
}

has() {
	local needle=$1
	shift
	# fast mode if possible; verify it doesn't have \001 in it already,
	# if not, than use regex w/ appropriate anchors to do it.
	if [[ *$'\001'* != "${*}" ]]; then
		pkgcore_IFS_push $'\001'
		# fast mode.
		if [[ "${IFS}${*}${IFS}" == *"${IFS}${needle}${IFS}"* ]]; then
			:
			pkgcore_IFS_pop
			return 0
		fi
		pkgcore_IFS_pop
		return 1
	fi
	# slow path
	pkgcore_shopt_push +x
	local x
	for x in "$@"; do
		if [ "${x}" == "${needle}" ]; then
			pkgcore_shopt_pop
			return 0
		fi
	done
	pkgcore_shopt_pop
	return 1
}

is_function() {
	declare -F "$1" &> /dev/null
} &> /dev/null

run_function_if_exists() {
	is_function "$1" || return 0
	"$@"
}

qa_run_function_if_exists() {
	is_function "$1" || return 0
	qa_invoke "$@"
}

directory_is_empty() {
	ls "$1" &> /dev/null && return 1
	return 0
}

PKGCORE_SHOPT_STACK=( )

pkgcore_shopt_push()
{
	PKGCORE_SHOPT_STACK[${#PKGCORE_SHOPT_STACK[@]}]=$(shopt -p)
	PKGCORE_SHOPT_STACK[${#PKGCORE_SHOPT_STACK[@]}]="$-"
	if [[ $1 == -s ]] || [[ $1 == -u ]]; then
		# shopt modification
		shopt "$@" || die "bad shopt options: $@"
	elif [ -n "$@" ]; then
		set "$@" || die "bad set invocation: $@"
	fi
	:
} &> /dev/null

pkgcore_shopt_pop()
{
	[ "$#" -ne 0 ] && die "bad invocation of pkgcore_shopt_pop; no args should be supplied, got $@"
	local count=$(( ${#PKGCORE_SHOPT_STACK[@]} - 1 ))
	[ "$count" -eq -1 ] && die "bad pkgcore_shopt_pop invocation; no matching push, stack was empty"
	local set_val="${PKGCORE_SHOPT_STACK[$count]}"
	if [[ "$-" != "${set_val}" ]]; then
		set ${-:++${-}} ${set_val:+-${set_val}} || die "failed enforcing set state of ${set_val}"
	fi
	unset PKGCORE_SHOPT_STACK[$count]
	count=$(( $count - 1 ))
	eval "${PKGCORE_SHOPT_STACK[$count]}" || die "failed restoring shopt settings: ${PKGCORE_SHOPT_STACK[$count]}"
	unset PKGCORE_SHOPT_STACK[$count]
	:
} &> /dev/null

declare -a PKGCORE_SAVED_IFS

pkgcore_IFS_push()
{
	PKGCORE_SAVED_IFS[${#PKGCORE_SAVED_IFS[@]}]="${IFS-unset}"
	if [[ $1 == unset ]]; then
		unset IFS
	else
		IFS="$1"
	fi
	:
}

pkgcore_IFS_pop()
{
	if [[ ${#PKGCORE_SAVED_IFS[@]} == 0 ]]; then
		die "pkgcore_IFS_pop invoked with nothing on the stack..."
	fi
	IFS=${PKGCORE_SAVED_IFS[$(( ${#PKGCORE_SAVED_IFS[@]} -1 ))]}
	[[ ${IFS} == unset ]] && unset IFS
	unset PKGCORE_SAVED_IFS[$(( ${#PKGCORE_SAVED_IFS[@]} -1 ))]
	:
}

qa_invoke()
{
	if ${PKGCORE_QA_SUPPRESSED:-false}; then
		"$@"
		return $(( $? ))
	fi
	local pkgcore_should_fail=false
	# save env and shopt settings.
	local PKGCORE_IFS_POS="${#PKGCORE_SAVED_IFS[@]}"
	local PKGCORE_SHOPT_POS="${#PKGCORE_SHOPT_STACK[@]}"
	pkgcore_IFS_push "${IFS}"
	pkgcore_shopt_push
	"$@"
	local ret=$?
	if [ "${PKGCORE_IFS_POS}" != $(( ${#PKGCORE_SAVED_IFS[@]} - 1 )) ]; then
		echo "QA warning: unbalanced pkgcore_IFS_push/pkgcore_IFS_pop detected.  internal error?"
		pkgcore_should_fail=true
	fi
	if [ ${PKGCORE_SHOPT_POS} != $(( ${#PKGCORE_SHOPT_STACK[@]} - 2 )) ]; then
		echo "QA warning: unbalanced pkgcore_shopt_push/pkgcore_shopt_pop detected. internal error?"
		pkgcore_should_fail=true
	fi

	if [ "${IFS-unset}" != "${PKGCORE_SAVED_IFS[${PKGCORE_IFS_POS}]}" ]; then
		echo "QA WARNING: invocation ${@} manipulated IFS to ${IFS}, but didn't restore it to it's original value!"
	fi
	pkgcore_IFS_pop

	pkgcore_shopt_push
	if [ "${PKGCORE_SHOPT_STACK[${PKGCORE_SHOPT_POS}]}" != "${PKGCORE_SHOPT_STACK[$(( $PKGCORE_SHOPT_POS + 2 ))]}" ]; then
		echo "QA WARNING; shopt modification bled out of invocation ${@}!"
	fi
	PKGCORE_SHOPT_POS+=1
	if [ "${PKGCORE_SHOPT_STACK[${PKGCORE_SHOPT_POS}]}" != "${PKGCORE_SHOPT_STACK[$(( $PKGCORE_SHOPT_POS + 2 ))]}" ]; then
		echo "QA WARNING; set modification bled out of invocation ${@}!"
	fi
	pkgcore_shopt_pop
	pkgcore_shopt_pop

	${pkgcore_should_fail} && die "invocation $@ modified globals and didn't clean up"
	return $(( $ret ))
}


unset_colors

:
