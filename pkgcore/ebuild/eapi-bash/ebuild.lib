#!/bin/bash
# ebuild.lib; ebuild phase processing, env handling
# Copyright 2005-2011 Brian Harring <ferringb@gmail.com>: BSD/GPL2

# general phase execution path-
# execute_phases is called, which sets EBUILD_PHASE, and then depending on the phase,
# loads or initializes.  Env is init'd for non src based stages if the env isn't found- otherwise
# it loads the environ via load_environ call.  In cases where env isn't found for phases setup -> merge,
# it bails (theres no way the env should be missing- exemption is setup phase).
#
# for env filtering for restoration and reloading, note the updates to DONT_EXPORT_(VARS|FUNCS).
# those vars are basically used to track what shouldn't be saved/restored.  Whitespace seperated,
# those vars can support posix (think egrep) regex.  They should hold all vars/funcs that are internal
# ebuild.sh vars.  Basically, filter all vars/funcs that are specific to ebuild.sh, not the ebuild.
#
# after loading the env, user defined pre hooks are executed, dyn_${EBUILD_PHASE} is executed,
# and the post hooks are executed.  If the env needs to be flushed to disk, MUST_EXPORT_ENV is set to
# "yes", and execute_phases will dump it to ${T}/environment.
#
# few notes on general env stuff- if it's not ebuild specific or a user option, it's typically marked
# readonly.  This limits users, but also helps to ensure that reloaded envs from older portages don't
# overwrite an internal ebd.sh function that has since changed.

ORIG_VARS=`declare | grep -E '^[^[:space:]{}()]+=' | cut -s -d '=' -f 1`
ORIG_FUNCS=`declare -F | cut -s -d ' ' -f 3`

DONT_EXPORT_VARS="ORIG_VARS GROUPS ORIG_FUNCS FUNCNAME DAEMONIZED CCACHE.* DISTCC.* SYNC
(TMP)?DIR FEATURES CONFIG_PROTECT.* WORKDIR RSYNC_.* GENTOO_MIRRORS
(DIST|FILES|RPM|ECLASS)DIR HOME MUST_EXPORT_ENV QA_CONTROLLED_EXTERNALLY COLORTERM HOSTNAME
myarg SANDBOX_.* BASH.* EUID PPID SHELLOPTS UID ACCEPT_(KEYWORDS|LICENSE) BUILD(_PREFIX|DIR) T DIRSTACK
DISPLAY (PKGCORE_)?EBUILD_PHASE PKGCORE_.* PORTAGE_.* SUDO_.* LD_PRELOAD ret line phases D IMAGE
PORT(_LOGDIR|DIR(_OVERLAY)?) ROOT TERM _ done e PROFILE_.* EBUILD ECLASS LINENO
HILITE TMP HISTCMD OPTIND RANDOM (OLD)?PWD PKGCORE_DOMAIN IFS BASHOPTS PKGCORE_DEBUG USER PIPESTATUS LINENO FUNCNAME _pipestatus
SHELL EMERGE_FROM MERGE_TYPE REPLACING_VERSIONS REPLACED_BY_VERSION (RESUME|FETCH)COMMAND(_.*)?"


if [ -z "$PKGCORE_BIN_PATH" ]; then
	echo "PKGCORE_BIN_PATH is unset!"
	exit 1
fi

# knock the sandbox vars back to the pkgs defaults.
reset_sandbox() {
	export SANDBOX_ON="1"
	export SANDBOX_PREDICT="${SANDBOX_PREDICT:+${SANDBOX_PREDICT}:}/proc/self/maps:/dev/console:/dev/random:${PORTAGE_TMPDIR}"
	export SANDBOX_WRITE="${SANDBOX_WRITE:+${SANDBOX_WRITE}:}/dev/shm:${PORTAGE_TMPDIR}"
	export SANDBOX_READ="${SANDBOX_READ:+${SANDBOX_READ}:}/dev/shm:${PORTAGE_TMPDIR}"
	local x
	for x in CCACHE_DIR DISTCC_DIR D WORKDIR T; do
		if [ -n "${!x}" ]; then
			addread  "${!x}"
			addwrite "${!x}"
		fi
	done
}

# Prevent aliases from causing portage to act inappropriately.
# Make sure it's before everything so we don't mess aliases that follow.
unalias -a

# We need this next line for "die" and "assert". It expands
# It _must_ preceed all the calls to die and assert.
shopt -s expand_aliases

# Unset some variables that break things.
unset GZIP BZIP BZIP2 CDPATH GREP_OPTIONS GREP_COLOR GLOB_IGNORE

# gentoo bug 309369; nasty alias, but it exists due to portage using declare's in env dumping.  declare statements are implicitly local.
# as such, the sourcing statement has to be in the same scope as the invoker of load_environ for that scope to get the changes
alias load_environ='{
	[[ -z ${PKGCORE_TARGET_ENV} ]] && die "load_environ was invoked w/out PKGCORE_TARGET_ENV set";
	[[ -z ${T} ]] && die "load_environ requires \$T to be set";
	EXISTING_PATH=${PATH};
	scrub_environ "${PKGCORE_TARGET_ENV}";source "${T}/.scrubbed-env" >&2 || die "sourcing scrubbed env failed";
	pkgcore_ensure_PATH "${EXISTING_PATH}";
	export EAPI=${PKGCORE_EAPI-${EAPI}}
	pkgcore_load_eapi_libs
	source_bashrcs
	unset -v EXISTING_PATH;
}'

alias init_environ='{
	EXISTING_PATH=${PATH};
	pkgcore_load_eapi_libs
	eval "$(generate_initial_ebuild_environ)" || die "failed loading initialized environment";
	pkgcore_ensure_PATH "${EXISTING_PATH}";
	source_bashrcs
	unset -v EXISTING_PATH;
}'

shopt -s extdebug &> /dev/null

#if no perms are specified, dirs/files will have decent defaults
#(not secretive, but not stupid)
umask 022

# the sandbox is disabled by default except when overridden in the relevant stages
export SANDBOX_ON="0"

# ensure the passed in PATH has its components in $PATH
pkgcore_ensure_PATH()
{
	local EXISTING_PATH="$1"
	local adds
	# note this isolates the adds in the same order they appear in
	# the passed in path, maintaining that order.
	if [ "$EXISTING_PATH" != "$PATH" ]; then
		pkgcore_push_IFS ':'
		local x
		for x in ${EXISTING_PATH}; do
			# keep in mind PATH=":foon" is a valid way to say "cwd"
			[ -z "${x}" ] && continue
			if ! has ${x} ${PATH} && ! has ${x} ${adds}; then
				adds="${adds:+${adds}:}${x}"
			fi
		done
		pkgcore_pop_IFS
		[ -n "$adds" ] && PATH="${PATH}${PATH:+:}${adds}"
	fi
	export PATH
}

pkgcore_load_eapi_libs() {
	# reload depend; while it may've been loaded already, reload it so that callers can
	# rely on this setting the env up as necessary
	# finally, update the filters with functionality loaded from here-
	# always, always, *always* use our own functionality
	source "${PKGCORE_BIN_PATH}/eapi/common.lib" || die "failed sourcing eapi/common.lib"
	source "${PKGCORE_BIN_PATH}/eapi/${PKGCORE_EAPI-${EAPI}}.lib" || \
		die "failed loading eapi/${PKGCORE_EAPI-${EAPI}}.lib"
}

# do all profile, bashrc's, and ebuild sourcing.  Should only be called in setup phase, unless the
# env is *completely* missing, as it is occasionally for ebuilds during prerm/postrm.
generate_initial_ebuild_environ() {
	local OCC="$CC"
	local OCXX="$CXX"
	local EXISTING_PATH="$PATH"

	if [ "${PKGCORE_EBUILD_PHASE}" == "setup" ]; then
		#we specifically save the env so it's not stomped on by sourcing.
		#bug 51552
		export_environ "${T}/.temp_env"

		if [ "$USERLAND" == "GNU" ]; then
			local PORTAGE_SHIFTED_PATH="$PATH"
			source /etc/profile.env &>/dev/null
			pkgcore_ensure_PATH "$EXISTING_PATH"
		fi

		#restore the saved env vars.
		PKGCORE_SUPPRESS_BASHRCS=true
		PKGCORE_TARGET_ENV="${T}/.temp_env"
		if ! load_environ; then
			#this shouldn't happen.
			die "failed to load ${T}/.tmp_env- fs is readonly?"
		fi
		unset SUPRESS_BASHRCS

		rm "${T}/.temp_env"
	fi

	load_ebuild "${EBUILD}"

	if [[ ${PKGCORE_EBUILD_PHASE} != depend ]]; then
		RESTRICT="${FINALIZED_RESTRICT}"
		unset FINALIZED_RESTRICT
		unset CC CXX
		[[ -n $OCC ]] && export CC="$OCC"
		[[ -n $OCXX ]] && export CXX="$OCXX"
		unset OCC OCXX
	fi

	pkgcore_ensure_PATH "$EXISTING_PATH"
	dump_environ || die "dump_environ returned non zero"
}

load_ebuild()
{
	local EBUILD="${1}"
	shift

	SANDBOX_ON="1"
	export S=${WORKDIR}/${P}

	# Expand KEYWORDS
	# We need to turn off pathname expansion for -* in KEYWORDS and
	# we need to escape ~ to avoid tilde expansion (damn bash) :)
	pkgcore_shopt_push -f
	KEYWORDS="$(echo ${KEYWORDS//~/\\~})"
	pkgcore_shopt_pop

	unset   IUSE   DEPEND   RDEPEND   PDEPEND
	unset E_IUSE E_DEPEND E_RDEPEND E_PDEPEND

	if [ ! -f "${EBUILD}" ]; then
		echo "bailing, ebuild not found at '$EBUILD'"
		die "EBUILD=${EBUILD}; problem is, it doesn't exist.  bye." >&2
	fi

	# XXX: temp hack to make misc broken eclasses behave, java-utils-2 for example
	# XXX: as soon as these eclasses behave, remove this.
	export DESTTREE=/usr

	source "${EBUILD}" >&2

	#a reasonable default for $S
	if [ "$S" = "" ]; then
		export S=${WORKDIR}/${P}
	fi

	#some users have $TMP/$TMPDIR to a custom dir in their home ...
	#this will cause sandbox errors with some ./configure
	#scripts, so set it to $T.
	export TMP="${T}"
	export TMPDIR="${T}"

	# Note: this next line is not the same as export RDEPEND=${RDEPEND:-${DEPEND}}
	# That will test for unset *or* NULL ("").  We want just to set for unset...

	if has ${EAPI-0} 0 1 2 3; then
		if [ "${RDEPEND-unset}" == "unset" ]; then
			export RDEPEND="${DEPEND}"
		fi
	fi

	#add in dependency info from eclasses
	IUSE="$IUSE $E_IUSE"
	DEPEND="${DEPEND} ${E_DEPEND}"
	RDEPEND="$RDEPEND $E_RDEPEND"
	PDEPEND="$PDEPEND $E_PDEPEND"

	EAPI="${EAPI-0}"

	unset E_IUSE E_DEPEND E_RDEPEND E_PDEPEND
}

# short version.  think these should be sourced via at the daemons choice, rather then defacto.
# note that exit-handling loads the die functions, thus the custom failure there.
source "${PKGCORE_BIN_PATH}/exit-handling.lib" >&2 || { echo "ERROR: failed sourcing exit-handling.lib"; exit -1; }
source "${PKGCORE_BIN_PATH}/ebuild-default-functions.lib" >&2 || die "failed sourcing ebuild-default-functions.lib"
source "${PKGCORE_BIN_PATH}/isolated-functions.lib" >&2 || die "failed sourcing stripped down functions.lib"
source "${PKGCORE_BIN_PATH}/ebuild-env-utils.lib" >&2 || die "failed sourcing ebuild-env-utils.lib"

pkgcore_run_ebuild_phase()
{
	[[ -n $PKGCORE_DEBUG ]] && set -x
	run_function_if_exists pkgcore_default_pre_${1}
	run_function_if_exists pre_${1}
	if is_function dyn_${1}; then
		dyn_${1}
	elif is_function ${1}; then
		${1}
	else
		run_function_if_exists pkgcore_default_${1}
	fi

	run_function_if_exists post_${1}
	run_function_if_exists pkgcore_default_post_${1}
	[[ $PKGCORE_DEBUG -lt 2 ]] && set +x
}

# general func to call for phase execution.  this handles necessary env loading/dumping, and executing pre/post/dyn
# calls.
execute_phases() {
	local PKGCORE_SAVE_ENV
	local PKGCORE_MUST_EXPORT_ENV=false

	# give us pretty tracebacks.
	shopt -s extdebug

	trap "exit 2" SIGINT
	trap "exit 9" SIGQUIT
	trap 'exit 1' SIGTERM
	trap 'die "a helper failed, see above"' SIGUSR1
	declare -rx PKGCORE_EBUILD_PROCESS_PID=$BASHPID

	if has ${EAPI:-0} 0 1 2 3; then
		declare -rx PKGCORE_NONFATAL_HELPER=1
	fi

	# local scope; this keeps it from bleeding further, and keeps
	# it from being exported- we use it to track if we're subshelled w/in the main
	# ebd instance, or if we're in a literal child process.
	local PKGCORE_IS_NOT_HELPER=1
	local myarg ret
	for myarg in $*; do
		PKGCORE_EBUILD_PHASE="$myarg"
		EBUILD_PHASE="$myarg"

		local PKGCORE_SAVE_ENV=true
		local PKGCORE_DIE_OUTPUT_DETAILS=true
		local PKGCORE_SUPPRESS_BASHRCS=false

		case $EBUILD_PHASE in
		nofetch|pretend)
			PKGCORE_SUPPRESS_BASHRCS=true
			init_environ

			PKGCORE_DIE_OUTPUT_DETAILS=false
			pkgcore_run_ebuild_phase pkg_${EBUILD_PHASE}
			PKGCORE_SAVE_ENV=false
			ret=0
			;;
		postrm)
			PKGCORE_SAVE_ENV=false
			# this is a fall thru; think of it as a select chunk w/out a break
			# we just snag these phases to turn off env saving.
			;&
		prerm|preinst|postinst|config)
			export SANDBOX_ON="0"

			PKGCORE_TARGET_ENV="${T}/environment"
			if ! load_environ; then
				#hokay.  this sucks.
				ewarn
				ewarn "failed to load env"
				ewarn "this installed pkg may not behave correctly"
				ewarn
				sleep 10
			fi

			pkgcore_run_ebuild_phase pkg_${EBUILD_PHASE}
			ret=0
			;;
		unpack|prepare|configure|compile|test|install)
			if [ "${SANDBOX_DISABLED="0"}" == "0" ]; then
				export SANDBOX_ON="1"
			else
				export SANDBOX_ON="0"
			fi

			[[ $PKGCORE_DEBUG -ge 3 ]] && set -x
			PKGCORE_TARGET_ENV="${T}/environment"
			if ! load_environ; then
				ewarn
				ewarn "failed to load env.  This is bad, bailing."
				die "unable to load saved env for phase $EBUILD_PHASE, unwilling to continue"
			fi

			[ -z "${S}" ] && die "S was null- ${S}, path=$PATH"

			pkgcore_run_ebuild_phase src_${EBUILD_PHASE}
			ret=0
			;;
		setup|setup-binpkg)
			#pkg_setup needs to be out of the sandbox for tmp file creation;
			#for example, awking and piping a file in /tmp requires a temp file to be created
			#in /etc.  If pkg_setup is in the sandbox, both our lilo and apache ebuilds break.

			EBUILD_PHASE="setup"

			# binpkgs don't need to reinitialize the env.
			if [ "$myarg"  == "setup" ]; then
				[ ! -z "${DISTCC_LOG}" ] && addwrite "$(dirname ${DISTCC_LOG})"

				local x
				# if they aren't set, then holy hell ensues.  deal.

				if has ccache $FEATURES; then
					[ -z "${CCACHE_SIZE}" ] && export CCACHE_SIZE="500M"
					ccache -M ${CCACHE_SIZE} &> /dev/null
				fi
				[[ $PKGCORE_DEBUG == 2 ]] && set -x
				init_environ
			else
				PKGCORE_TARGET_ENV="${T}/environment"
				if ! load_environ; then
					die "failed loading saved env; at ${T}/environment"
				fi
			fi

			export SANDBOX_ON="0"
			pkgcore_run_ebuild_phase pkg_${EBUILD_PHASE}
			ret=0;

			;;
		depend)
			SANDBOX_ON="1"
			PKGCORE_SAVE_ENV=false

			PKGCORE_DIE_OUTPUT_DETAILS=false
			if [ -z "$QA_CONTROLLED_EXTERNALLY" ]; then
				enable_qa_interceptors
			fi

			load_ebuild "${EBUILD}"

			if [ -z "$QA_CONTROLLED_EXTERNALLY" ]; then
				disable_qa_interceptors
			fi

			pkgcore_dump_metadata_keys
			;;
		*)
			export SANDBOX_ON="1"
			echo "Please specify a valid command: $EBUILD_PHASE isn't valid."
			echo
			dyn_help
			exit 1
			;;
		esac

		${PKGCORE_SAVE_ENV} && PKGCORE_MUST_EXPORT_ENV=true
		[[ $PKGCORE_DEBUG -lt 4 ]] && set +x
	done

	if ${PKGCORE_MUST_EXPORT_ENV}; then
		export_environ "${T}/environment"
	fi
	return ${ret:-0}
}

pkgcore_dump_metadata_keys() {
	pkgcore_shopt_push -f
	local key
	for key in EAPI DEPEND RDEPEND SLOT SRC_URI RESTRICT HOMEPAGE LICENSE \
		DESCRIPTION KEYWORDS INHERITED IUSE PDEPEND PROVIDE PROPERTIES; do
		# deref the val, if it's not empty/unset, then spit a key command to EBD
		# after using echo to normalize whitespace (specifically removal of newlines)
		[ "${!key:-unset}" != "unset" ] && ebd_write_line "key ${key}=$(echo ${!key})"
	done
	pkgcore_shopt_pop

	# defined phases... fun one.
	local phases
	for key in pkg_{pretend,configure,info,{pre,post}{rm,inst},setup} \
		src_{unpack,prepare,configure,compile,test,install}; do
			is_function "${key}" && phases="${phases} ${key}"
	done
	ebd_write_line "key DEFINED_PHASES=${phases:--}"
}

DONT_EXPORT_VARS="${DONT_EXPORT_VARS} $(declare | invoke_filter_env --print-vars | regex_filter_input ${ORIG_VARS} ${DONT_EXPORT_VARS})"

set +f

export XARGS
set +H -h
DAEMONIZED="yes"
export DAEMONIZED
readonly DAEMONIZED
:
