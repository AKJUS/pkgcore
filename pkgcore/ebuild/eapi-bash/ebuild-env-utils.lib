# Copyright 2005-2011 Brian Harring <ferringb@gmail.com>: BSD/GPL2
# this functionality is all related to saving/loading environmental dumps for ebuilds

pkgcore_regex_filter_input() {
	pkgcore_IFS_push '|'
	local regex="^(${*})$"
	pkgcore_IFS_pop
	# use egrep if possible... tis faster.
	local l=$(type -p egrep)
	if [[ -n $l ]]; then
		# use type -p; qa_interceptors may be be active.
		"$l" -v "${regex}"
		local ret=$?
		[[ $ret -gt 1 ]] && die "got failing return code (${ret}) invoking pkgcore_regex_filter_input in egrep -v mode with args: ${regex}"
	else
		while read l; do
			[[ $l =~ $regex ]] || echo "${l}"
		done
	fi
}

pkgcore_escape_regex_chars() {
	local x="$1"
	x="${x//\+/\\+}"
	x="${x//\./\\.}"
	x="${x//\*/\\*}"
	echo "${x}"
}

pkgcore_get_env_funcs() {
	declare -F | cut -s -d ' ' -f3 -s
}

pkgcore_filter_env() {
	local opts
	[[ $PKGCORE_DEBUG -ge 3 ]] && opts="$opts --debug"
	PYTHONPATH="${PKGCORE_PYTHONPATH}" "${PKGCORE_PYTHON_BINARY}" \
	"${PKGCORE_BIN_PATH}/filter-env" "$@" || \
		die "filter-env invocation failed"
}

# selectively saves  the environ- specifically removes things that have been marked to not be exported.
# dump the environ to stdout.
pkgcore_dump_environ() {

	# if possible, sort the outputting of funcs/vars; this isn't required however.
	local PKGCORE_SORT=$(type -p sort 2> /dev/null)
	[[ -z "${PKGCORE_SORT}" ]] && PKGCORE_SORT=cat

	pkgcore_shopt_push -f
	declare -a PKGCORE_TARGETS=( $(pkgcore_get_env_funcs | pkgcore_regex_filter_input ${DONT_EXPORT_FUNCS} | ${PKGCORE_SORT}) )
	local PKGCORE_RET=$?
	if [[ "$PKGCORE_RET" != "0" ]]; then
		die "failed invoking pkgcore_get_env_funcs/regex filtering: ret $PKGCORE_RET" >&2
	fi
	if [[ 0 != "${#PKGCORE_TARGETS[@]}" ]]; then
		declare -f "${PKGCORE_TARGETS[@]}" || die "failed outputing funcs ${PKGCORE_TARGETS[@]}" >&2
	fi

	PKGCORE_TARGETS=( $(declare | pkgcore_filter_env --print-vars | pkgcore_regex_filter_input ${DONT_EXPORT_VARS} | ${PKGCORE_SORT}) )
	PKGCORE_RET=$?
	if [[ "$PKGCORE_RET" != 0 ]]; then
		die "failed invoking pkgcore_get_env_vars/regex filtering: ret $PKGCORE_RET" >&2
	fi
	if [[ 0 != "${#PKGCORE_TARGETS[@]}" ]]; then
		declare -p "${PKGCORE_TARGETS[@]}" || die "failed outputing env vars ${PKGCORE_TARGETS[@]}" >&2
	fi
	pkgcore_shopt_pop
}

# dump environ to $1, optionally piping it through $2 and redirecting $2's output to $1.
pkgcore_export_environ() {
	if [[ $# != 1 ]] && [[ $# != 2 ]]; then
		die "pkgcore_export_environ requires at least one arguement, two max; given $@"
	fi

	#the spaces on both sides are important- otherwise, the later ${DONT_EXPORT_VARS/ temp_umask /} won't match.
	#we use spaces on both sides, to ensure we don't remove part of a variable w/ the same name-
	# ex: temp_umask_for_some_app == _for_some_app.
	#Do it with spaces on both sides.

	DONT_EXPORT_VARS="${DONT_EXPORT_VARS} temp_umask "
	local temp_umask=`umask`
	umask 0002

	if [[ $# == 1 ]]; then
		pkgcore_dump_environ > "$1"
	else
		pkgcore_dump_environ | $2 > "$1"
	fi
	chown portage:portage "$1" &>/dev/null
	chmod 0664 "$1" &>/dev/null

	DONT_EXPORT_VARS="${DONT_EXPORT_VARS/ temp_umask /}"

	umask $temp_umask
}

# reload a saved env, applying usual filters to the env prior to eval'ing it.
pkgcore_scrub_environ() {
	local src e ret EXISTING_PATH
	# localize these so the reload doesn't have the ability to change them

	if [[ $# != 1 ]]; then
		die "load_environ called with wrong args, only one can be given: $@"
	fi

	[[ ! -f "$1" ]] && die "pkgcore_scrub_environ called with a nonexist env: $1"

	src="$1"

	# here's how this goes; we do an eval'd loadup of the target env w/in a subshell..
	# declares and such will slide past filter-env (so it goes).  we then use our own
	# pkgcore_dump_environ from within to get a clean dump from that env, and load it into
	# the parent eval.
	(

		# protect the core vars and functions needed to do a pkgcore_dump_environ
		# some of these are already readonly- we still are forcing it to be safe.
		declare -r PKGCORE_PYTHONPATH="${PKGCORE_PYTHONPATH}" &> /dev/null
		declare -r PKGCORE_PYTHON_BINARY="${PKGCORE_PYTHON_BINARY}" &> /dev/null
		declare -r DONT_EXPORT_VARS="${DONT_EXPORT_VARS}" &> /dev/null
		declare -r DONT_EXPORT_FUNCS="${DONT_EXPORT_FUNCS}" &> /dev/null
		declare -r SANDBOX_ON="${SANDBOX_ON}" &> /dev/null
		declare -r T="${T}" &> /dev/null
#		declare -rx PATH="${PATH}" &> /dev/null

		readonly -f pkgcore_filter_env &> /dev/null
		readonly -f pkgcore_dump_environ &> /dev/null
		readonly -f pkgcore_regex_filter_input &> /dev/null

		pkgcore_shopt_push -f
		pkgcore_IFS_push $'\n '
		declare -a PKGCORE_ENV_ARRAY=( ${DONT_EXPORT_FUNCS} )
		declare -a PKGCORE_VAR_ARRAY=( ${DONT_EXPORT_VARS} src x EXISTING_PATH )
		pkgcore_IFS_pop
		pkgcore_IFS_push ,
		PKGCORE_ENV_ARRAY="${PKGCORE_ENV_ARRAY[*]}"
		PKGCORE_VAR_ARRAY="${PKGCORE_VAR_ARRAY[*]}"
		pkgcore_IFS_pop
		pkgcore_shopt_pop

		rm -f "${T}/.pre-scrubbed-env" || die "failed rm'ing"
		# run the filtered env.
		pkgcore_filter_env \
			-f "${PKGCORE_FUNC_ARRAY}" \
			-v "${PKGCORE_ENV_ARRAY}" \
			-i "$src" \
			> "${T}/.pre-scrubbed-env" || die "failed first step of scrubbing the env to load"

		[[ -s "${T}/.pre-scrubbed-env" ]] || die "empty pre-scrubbed-env file.  pkgcore bug?"
		source "${T}/.pre-scrubbed-env" >&2 || die "failed sourcing scrubbed env"


		# if reinstate_loaded_env_attributes exists, run it to add to the vars.
		# old pkgcore env saving approach, long before portage/paludis were around...
		type reinstate_loaded_env_attributes &> /dev/null && \
			reinstate_loaded_env_attributes
		unset -f reinstate_loaded_env_attributes

		# ok. it's loaded into this subshell... now we use our dump mechanism (which we trust)
		# to output it- this mechanism is far more bulletproof then the load filtering (since
		# declare and friends can set vars via many, many different ways), thus we use it
		# as the final filtering.

		unset -v EXISTING_PATH old_phase

		rm -f "${T}/.scrubbed-env"
		pkgcore_dump_environ > ${T}/.scrubbed-env || die "dumping environment failed"
	) && return

	echo "die 'failed parsing the env dump'" # yep, we're injecting code into the eval.
	exit 1
	# note no die usage here... exit instead, since we don't want another tb thrown
}
