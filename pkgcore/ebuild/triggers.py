# Copyright: 2006 Brian Harring <ferringb@gmail.com>
# License: GPL2

from pkgcore.merge import triggers
from pkgcore.util.file import read_bash_dict, AtomicWriteFile
from pkgcore.fs import fs
from pkgcore.util.currying import pre_curry
import os, errno

colon_parsed = set(["ADA_INCLUDE_PATH",  "ADA_OBJECTS_PATH", "LDPATH", "MANPATH", 
	"PATH", "PRELINK_PATH", "PRELINK_PATH_MASK", "PYTHONPATH"])

incrementals = set(['ADA_INCLUDE_PATH', 'ADA_OBJECTS_PATH', 'CLASSPATH', 'CONFIG_PROTECT', 
	'CONFIG_PROTECT_MASK', 'INFODIR', 'INFOPATH', 'KDEDIRS', 'LDPATH', 'MANPATH', 
	'PATH', 'PRELINK_PATH', 'PRELINK_PATH_MASK', 'PYTHONPATH', 'ROOTPATH'])

def raw_env_update(reporter, cset):
	pjoin = os.path.join
	offset = reporter.offset
	if reporter.offset is None:
		offset = "/"
	base = pjoin(reporter.offset, "etc/env.d")
	collapsed_d = {}
	for x in sorted(os.listdir(base)):
		if x.endswith(".bak") or x.endswith("~") or x.startswith("._cfg") or len(x) > 3 or x[0:2].isdigit():
			continue
		d = read_bash_dict(pjoin(base, x))
		# inefficient, but works.
		for k in d:
			if k in incrementals:
				if k in colon_parsed:
					collapsed_d.setdefault(k, []).extend(d[k].split(":"))
				else:
					collapsed_d.setdefault(k, []).append(d[k])
			else:
				collapsed_d[k] = d[k]
		del d
	
	if "LDPATH" in collapsed_d:
		# we do an atomic rename instead of open and write quick enough (avoid the race iow)
		fp = pjoin(offset, "etc", "ld.so.conf")
		new_f = AtomicWriteFile(fp)
		new_f.write("# automatically generated, edit env.d files instead\n")
		new_f.writelines(x.strip() for x in collapsed_d)
		new_f.close()
		del collapsed_d["LDPATH"]
	
	d = {}
	for k, v in collapsed_d.iteritems():
		if k in colon_parsed:
			d[k] = ":".join(v)
		else:
			d[k] = v[-1]

	new_f = pjoin(offset, "etc", "profile.env")
	new_f.write("# autogenerated.  update env.d instead\n")
	new_f.writelines('export %s="%s"\n' % (k, v) for k,v in d.iteritems())
	new_f.close()
	new_f = pjoin(offset, "etc", "profile.csh")
	new_f.write("# autogenerated, update env.d instead\n")
	new_f.writelines('setenv %s="%s"\n' % (k, v) for k,v in d.iteritems())
	new_f.close()

def env_update_trigger(cset="install"):
	return triggers.SimpleTrigger(cset, raw_env_update)


def config_protect_func(install_cset, existing_cset, protected_filter, engine, csets):
	install_cset = csets[install_cset]
	existing_cset = csets[existing_cset]
	protected = {}
	pdir = os.path.dirname
	pbase = os.path.basename
	pjoin = os.path.join
	fisdir = fs.isdir
	for x in existing_cset:
		if fisdir(x):
			continue
		elif protected_filter(x):
			replacement = install_cset[x.location]
			if replacement.chksums != x.chksums:
				protected.setdefault(pdir(x.location), []).append((pbase(x), x))

	for dir_loc, entries in protected.iteritems():
		updates = dict((x[0], -1) for x in entries)
		try:
			existing = sorted(x for x in os.listdir(dir_loc) if x.startswith("._cfg"))
		except OSError, oe:
			if oe.errno != errno.ENOENT:
				raise
			# this shouldn't occur.
			continue
		
		for x in existing:
			try:
				# ._cfg0000_filename
				count = int(x[5:9])
				if x[9] != "_":
					raise ValueError
				fn = x[10:]
			except (ValueError, IndexError):
				continue
			if fn in updates:
				updates[fn] = max(updates[fn], count)
			
		# now we rename.
		for fname, entry in entries:
			try:
				install_cset.remove(entry)
			except KeyError:
				# this shouldn't occur...
				continue
			new_fn = pjoin(dir_loc, "._cfg%i_%s" % (count + 1, fname))
			install_cset.add(entry.change_attributes(real_location=new_fn))
		del updates

def config_protect_trigger(existing_cset="install_existing", modifying_cset="cset"):
	return triggers.trigger([existing_cset, modifying_cset], pre_curry(config_protect_func, existing_cset, modifying_cset))
