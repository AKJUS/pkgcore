# Copyright: 2014-2016 Tim Harder <radhermit@gmail.com>
# license GPL2/BSD 3

source "${PKGCORE_EBD_PATH}"/eapi/5.lib

PKGCORE_EAPPLY_USER=

get_libdir() { __get_libdir lib; }

eapply() {
	local -a options files
	local token end_options bad_options

	for token in "${@}"; do
		if [[ -n ${end_options} ]]; then
			files+=( "${token}" )
		elif [[ ${token} == -- ]]; then
			[[ ${#files[@]} -eq 0 ]] || bad_options=1
			end_options=1
		elif [[ ${token} == -* ]]; then
			[[ ${#files[@]} -eq 0 ]] || bad_options=1
			options+=( "${token}" )
		else
			files+=( "${token}" )
		fi
	done

	[[ -n ${bad_options} ]] && die "${FUNCNAME}: options must be specified before file arguments"
	[[ ${#files[@]} -eq 0 ]] && die "${FUNCNAME}: no patches or directories specified"

	__shopt_push -s nullglob
	__var_push LC_COLLATE=POSIX

	local -a paths patches
	local path f
	for path in "${files[@]}"; do
		if [[ -d ${path} ]]; then
			for f in "${path}"/*; do
				[[ -f ${f} ]] && [[ ${f} == *.diff || ${f} == *.patch ]] && paths+=( "${f}" )
			done
			[[ ${#paths[@]} -eq 0 ]] && die "${FUNCNAME}: no patches in directory: ${path}"
			patches+=( "${paths[@]}" )
		else
			patches+=( "${path}" )
		fi
	done

	__var_pop
	__shopt_pop

	local ret
	for f in "${patches[@]}"; do
		if [[ ${PKGCORE_DEBUG} -ge 1 ]]; then
			echo patch -p1 -f -s -g0 --no-backup-if-mismatch "${options[@]}" \< "${x}" 1>&2
		else
			ebegin "Applying ${f##*/}"
		fi
		patch -p1 -f -s -g0 --no-backup-if-mismatch "${options[@]}" < "${f}"
		ret=$?
		if ! eend "${ret}"; then
			${PKGCORE_NONFATAL} && return "${ret}"
			die "${FUNCNAME}: applying patch failed: ${f}"
		fi
	done

	return 0
}

eapply_user() {
	# Apply valid user patches, filenames must match *.diff or
	# *.patch to be included.
	#
	# valid patch directories:
	#   - ${CATEGORY}/${PF}(:${SLOT})
	#   - ${CATEGORY}/${P}(:${SLOT})
	#   - ${CATEGORY}/${PN}(:${SLOT})

	[[ ${EBUILD_PHASE} == "prepare" ]] || die "${FUNCNAME}: called during invalid phase: ${EBUILD_PHASE}"
	# return if eapply_user has already been called
	[[ -n ${PKGCORE_EAPPLY_USER} ]] && return
	PKGCORE_EAPPLY_USER=0

	local patchdir=${ROOT:-/}etc/portage/patches
	local -a patches

	__shopt_push -s nullglob
	__var_push LC_COLLATE=POSIX
	local dir f
	for dir in "${patchdir}"/${CATEGORY}/{${PF},${P},${PN}}{,:${SLOT%/*}}; do
		for f in "${dir}"/*; do
			[[ -f ${f} ]] && [[ ${f} == *.diff || ${f} == *.patch ]] && patches+=( "${f}" )
		done
	done
	__var_pop
	__shopt_pop

	if [[ ${#patches[@]} -gt 0 ]]; then
		ewarn "Applying user patches"
		eapply "${patches[@]}"
	fi
}

__phase_post_src_prepare() {
	[[ -z ${PKGCORE_EAPPLY_USER} ]] && die "eapply_user (or default) must be called in src_prepare()"
}

:
