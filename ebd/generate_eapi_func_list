#!/usr/bin/env bash
#
# Generate the list of functions specific to an EAPI version.
#
# This script is run dynamically in a repo or tarball layout on initialization
# of the build environment for each ebuild since different EAPIs require
# different lists of functions to be skipped. For installed versions, static
# function lists are generated at install time and used instead.

ONLY=false
VISIBLE=false

while getopts "ov" opt; do
	case ${opt} in
		o) ONLY=true ;;
		v) VISIBLE=true ;;
		*) ;;
	esac
done

shift $((OPTIND-1))
EAPI=${1:-0}
export PKGCORE_EBD_PATH=${BASH_SOURCE[0]%/*}

# without this var, parsing certain things can fail; force to true if unset or
# null so any code that tried accessing it thinks it succeeded
export PKGCORE_PYTHON_BINARY=${PKGCORE_PYTHON_BINARY:-/bin/true}

if ${ONLY}; then
	PREV_EAPI=$((EAPI-1))
	if [[ -f "${PKGCORE_EBD_PATH}/eapi/${PREV_EAPI}.bash" ]]; then
		source "${PKGCORE_EBD_PATH}/eapi/${PREV_EAPI}.bash" \
			|| { echo "failed loading eapi/${PREV_EAPI}.bash" >&2; exit 1; }
		source "${PKGCORE_EBD_PATH}/eapi/${PREV_EAPI}-phase.bash" \
			|| { echo "failed loading eapi/${PREV_EAPI}-phase.bash" >&2; exit 1; }
		PREV_EAPI_FUNCS=( $(compgen -A function) )
	fi
fi

source "${PKGCORE_EBD_PATH}/eapi/${EAPI}.bash" \
	|| { echo "failed loading eapi/${EAPI}.bash" >&2; exit 1; }
source "${PKGCORE_EBD_PATH}/eapi/${EAPI}-phase.bash" \
	|| { echo "failed loading eapi/${EAPI}-phase.bash" >&2; exit 1; }

if ${ONLY}; then
	for func in "${PREV_EAPI_FUNCS[@]}"; do
		unset -f ${func}
	done
fi

if ! ${VISIBLE}; then
	INTERNAL_FUNCS=( $(compgen -A function __) )
fi

# Sorting order; put PMS functionality first, then our internals.
printf '%s\n' $(compgen -X '__*' -A function) ${INTERNAL_FUNCS[@]}
