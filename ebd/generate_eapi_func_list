#!/usr/bin/env bash
#
# Generate the list of functions specific to an EAPI version.
#
# This script is run dynamically in a repo or tarball layout on initialization
# of the build environment for each ebuild since different EAPIs require
# different lists of functions to be skipped. For installed versions, static
# function lists are generated at install time and used instead.

ONLY=false
VISIBLE=false

while getopts "ov" opt; do
	case ${opt} in
		o) ONLY=true ;;
		v) VISIBLE=true ;;
		*) ;;
	esac
done

shift $((OPTIND-1))
EAPI=${1:-0}
export PKGCORE_EBD_PATH=${BASH_SOURCE[0]%/*}

# without this var, parsing certain things can fail; force to true if unset or
# null so any code that tried accessing it thinks it succeeded
export PKGCORE_PYTHON_BINARY=${PKGCORE_PYTHON_BINARY:-/bin/true}

shopt -s nullglob
if ${ONLY}; then
	for file in "${PKGCORE_EBD_PATH}/eapi/${EAPI}"/*.bash; do
		source "${file}" || { echo "failed loading ${file}" >&2; exit 1; }
	done
else
	for (( eapi=0 ; eapi<=${EAPI} ; eapi++ )) ; do
		for file in "${PKGCORE_EBD_PATH}/eapi/${eapi}"/*.bash; do
			source "${file}" || { echo "failed loading ${file}" >&2; exit 1; }
		done
	done
fi

${VISIBLE} || INTERNAL_FUNCS=( $(compgen -A function __) )

# Sorting order; put PMS functionality first, then our internals.
printf '%s\n' $(compgen -X '__*' -A function) ${INTERNAL_FUNCS[@]}
