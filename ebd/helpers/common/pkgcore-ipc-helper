#!/usr/bin/env bash

# protect against env screwups.
if [[ -z ${PKGCORE_EBD_PATH} ]]; then
	PKGCORE_EBD_PATH=$(readlink -f "${0}")
	# and go up 3, out of helpers.
	PKGCORE_EBD_PATH=${PKGCORE_EBD_PATH%/*}
	PKGCORE_EBD_PATH=${PKGCORE_EBD_PATH%/*}
	PKGCORE_EBD_PATH=${PKGCORE_EBD_PATH%/*}
fi
export PKGCORE_EBD_PATH

source "${PKGCORE_EBD_PATH}"/exit-handling.bash || {
	echo "failed to load exit-handling library: PKGCORE_EBD_PATH=${PKGCORE_EBD_PATH}" >&2
	exit -127
}

if [[ $# -lt 1 ]]; then
	die "ipc-helper invoked without a target helper; no args given."
fi

source "${PKGCORE_EBD_PATH}"/ebuild-daemon-lib.bash || \
	die "failed to load ebuild-daemon-lib.bash"
source "${PKGCORE_EBD_PATH}"/isolated-functions.bash || \
	die "failed to load isolated-functions.bash"
source "${PKGCORE_EBD_PATH}"/eapi/depend.bash >&2 || \
	die "failed sourcing eapi/depend.bash"
source "${PKGCORE_EBD_PATH}"/eapi/common.bash >&2 || \
	die "failed sourcing eapi/common.bash"
source "${PKGCORE_EBD_PATH}"/helpers/internals/helper-lib.bash >&2 || \
	die "failed sourcing helpers/internals/helper-lib.bash"

HELPER_ERROR_PREFIX=

if ! ${PKGCORE_PREFIX_SUPPORT:=false}; then
	export ED=${D}
elif [[ ${ED:-unset} == "unset" ]]; then
	error "The variable ED is missing from the environment, but is required for prefix mode; failing."
	exit -1
fi

# run an ebuild command on the python side and return its status
__ebd_ipc_cmd() {
	local cmd=$1 opts=$2 ret_str
	local -a ret
	shift 2

	__ebd_write_line ${cmd}
	__ebd_write_line ${PKGCORE_NONFATAL:-false}
	__ebd_write_line ${opts}
	# Send arg list as a single string using a null char delimiter terminated by a newline.
	# Note that this requires printf as echo doesn't appear to respect IFS=$'\0'.
	printf "%s\0" "$@" >&${PKGCORE_EBD_WRITE_FD}
	__ebd_write_line

	# Split return status into array of return code and optional error message.
	# This uses a bell char as a delimiter since the null char can't be
	# assigned to variables.
	__ebd_read_line ret_str
	IFS=$'\x07' read -ra ret <<< "${ret_str}"
	__helper_exit "${ret[@]}"
}

run_ipc_cmd() {
	[[ $# -eq 0 ]] && die "${FUNCNAME}: missing required arguments"
	local HELPER_PATH=$1
	local HELPER_NAME=${1##*/}
	local HELPER_EAPI=${1%/*}
	HELPER_EAPI=${HELPER_EAPI##*/}
	shift
	local HELPER_ARG_COUNT=$#
	if [[ ! -e ${HELPER_PATH} ]]; then
		# note this can daftly go find a binary...
		HELPER_PATH=$(type -p "${HELPER_NAME}")
		[[ -z ${HELPER_PATH} ]] && die "couldn't find implementation of ${HELPER_NAME}!?"
	fi

	local OLD_ERROR_PREFIX=${HELPER_ERROR_PREFIX}
	local HELPER_ERROR_PREFIX=${OLD_ERROR_PREFIX:+${OLD_ERROR_PREFIX}: }${HELPER_NAME}

	local IPC_CMD=${HELPER_NAME}
	source "${HELPER_PATH}"

	# load main command opts when running a subcommand
	if [[ ${HELPER_NAME} != ${IPC_CMD} ]]; then
		source "$(type -p ${IPC_CMD})" >&2 || die "failed sourcing ${IPC_CMD}"
	fi

	__ebd_ipc_cmd ${IPC_CMD} "${OPTIONS[*]}" "$@"
}
run_ipc_cmd "$@"
exit $(( $? ))
