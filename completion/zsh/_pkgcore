#compdef pebuild pinspect pmaint pmerge pquery

typeset -a common_main_args common_output_args common_args domain_common_args

common_main_args=(
  '(- :)'--version'[show version information and exit]'
  '--add-config[modify an existing configuration section]'
  '--new-config[add a new configuration section]'
  '--empty-config[do not load user/system configuration]'
  '--config[override location of config files]:config path:_files'
  "--color=[Color output]:yes/no:((y\:'yes' n\:'no'))"
)

common_output_args=(
  '(- :)'{-h,--help}'[show help information and exit]'
  '(--debug --help -h)--debug[enable debugging output]'
  '(--quiet -q --verbose -v)'{-q,--quiet}'[suppress non-error output]'
  '(--verbose -v --quiet -q)'{-v,--verbose}'[show verbose output]'
)

common_args=(
  $common_main_args
  $common_output_args
)

domain_common_args=(
  $common_args
  '--domain[domain to use for this operation]'
)

_pebuild() {
  local curcontext=$curcontext state state_descr line ret=1
  typeset -A opt_args

  _arguments -C \
    $domain_common_args \
    "--no-auto[run just the specified phases; it's up to the invoker to get the order right]" \
    '(-): :->atom-or-ebuild' \
    '(-)*:: :->phase' \
    && ret=0

  case $state in
    (atom-or-ebuild)
      _arguments \
        '*:ebuild:_files -g \*.ebuild' \
        && ret=0
      ;;
    (phase)
      typeset -a phases

      phases=(
        setup:'run package specific setup actions or checks'
        unpack:'unpack all the sources to the workdir'
        prepare:'preparation of all sources such as applying patches'
        configure:'run configuration steps'
        compile:'run compilation steps'
        test:'run test steps'
        install:'install the package to the temp directory'
        clean:"remove the package's temporary directory"
      )

      _describe -V -t phases phase phases && ret=0
      ;;

    (*)
      _nothing
      ;;
  esac

  return ret
}

_pinspect() {
  local curcontext=$curcontext state state_descr line ret=1
  typeset -A opt_args

  _arguments -C \
    $common_args \
    '(-): :->command' \
    '(-)*:: :->subcommand' \
    && ret=0

  case $state in
    (command)
      typeset -a subcommands

      subcommands=(
        pkgsets:'pkgset related introspection'
        eapi_usage:'report of eapi usage for targeted repos'
        license_usage:'report of license usage for targeted repos'
        eclass_usage:'report of eclass usage for targeted repos'
        mirror_usage:'report of SRC_URI mirror usage for targeted repos'
        distfiles_usage:'report detailing distfiles space usage for targeted repos'
        query:'auxiliary access to ebuild/repository info via portageq akin API'
        portageq:'portageq compatible interface to query commands'
        profile:'profile related querying'
        digests:'identify what packages are missing digest info'
      )

      _describe -t subcommands subcommand subcommands && ret=0

      ;;
    (subcommand)
      curcontext=${curcontext%:*}-$line[1]:

      typeset -a historical_repo_data_opts
      historical_repo_data_opts=(
        '(- :)'{-h,--help}'[show help information and exit]'
        '--no-final-summary[disable outputting a summary of data across all repos]'
        '--sort-by-name[sort output by name, rather then by frequency]'
        '--first[show only the first N detail items]:number'
        '--last[show only the last N detail items]:number'
        '*:repo:_repos -i -s'
      )

      case $line[1] in
        (pkgsets)
          _arguments -C -A '-*' \
            '(- :)'{-h,--help}'[show help information and exit]' \
            '--all[display info on all pkgsets]' \
            ':pkgset:' \
            && ret=0
          ;;
        ((eapi|license|eclass|mirror)_usage)
          _arguments -C -A '-*' \
            $historical_repo_data_opts \
            && ret=0
          ;;
        (distfiles_usage)
          _arguments -C -A '-*' \
            '--no-repo-summary[disable outputting repo summaries]' \
            '--no-detail[disable outputting a detail view of all repos]' \
            '--include-nonmirrored[if set, nonmirrored distfiles will be included in the total]' \
            '--include-restricted[if set, fetch restricted distfiles will be included in the total]' \
            $historical_repo_data_opts \
            && ret=0
          ;;
        (query)
          ;;
        (portageq)
          ;;
        (profile)
          typeset -a profile_attrs

          profile_attrs=(
            parent:'output the linearized tree of inherited parents'
            eapi:'output EAPI support required for reading this profile'
            deprecated:'dump deprecation notices, if any'
            provided:'list all package.provided packages'
            system:'output the system package set'
            use_expand:'output the USE_EXPAND configuration for this profile'
            iuse_effective:'output the IUSE_EFFECTIVE value for this profile'
            masks:'inspect package masks'
            unmasks:'inspect package unmasks'
            bashrcs:'inspect bashrcs'
            keywords:'inspect package.keywords'
            accept_keywords:'inspect package.accept_keywords'
            use:'inspect package.use'
            masked_use:'inspect masked use flags'
            stable_masked_use:'inspect stable masked use flags'
            forced_use:'inspect forced use flags'
            stable_forced_use:'inspect stable forced use flags'
            defaults:'inspect defined configuration for this profile'
            arch:'output the arch defined for this profile'
            status:'output the status of this profile'
          )

          _arguments -C -w -S -s -A '-*' \
            '(- :)'{-h,--help}'[show help information and exit]' \
            '1:profile attribute:(($profile_attrs))' \
            '2:profile:_profiles -f' \
            && ret=0
          ;;
        (digests)
          _arguments -C -A '-*' \
            '(- :)'{-h,--help}'[show help information and exit]' \
            ':repo:_repos' \
            && ret=0
          ;;
        (*)
          _nothing
          ;;
      esac
      ;;
  esac
  return ret
}

_pmaint() {
  local curcontext=$curcontext state state_descr line ret=1
  typeset -A opt_args

  _arguments -C \
    $common_args \
    '(-): :->command' \
    '(-)*:: :->subcommand' \
    && ret=0

  case $state in
    (command)
      typeset -a subcommands

      subcommands=(
        sync:'synchronize a local repository with its defined remote'
        copy:'copy binpkgs between repositories; primarily useful for quickpkging a livefs pkg'
        regen:'regenerate repository caches'
        perl-rebuild:'perl-rebuild support for use after upgrading perl (experimental)'
        env-update:'update env.d and ldconfig'
        mirror:'mirror the sources for a package in full'
        digest:'update package manifests'
      )

      _describe -t subcommands subcommand subcommands && ret=0
      ;;
    (subcommand)
      curcontext=${curcontext%:*}-$line[1]:

      case $line[1] in
        (sync)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            '*:repo:_repos' \
            && ret=0
          ;;
        (copy)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            {'(--source-repo)-s','(-s)--source-repo'}'[copy strictly from the supplied repository]:repo:_repos' \
            {'(--ignore-missing)-i','(-i)--ignore-missing'}"[if a matching pkg already exists in the target, don't update it]" \
            ':target repo:_repos' \
            ':query:' \
            && ret=0
          ;;
        (regen)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            '--disable-eclass-caching[disable caching eclasses into functions (results in a ~2x slower regen process, only disable when debugging)]' \
            {'(--threads)-t','(-t)--threads'}'[number of threads to use for regeneration (defaults to using all available processors]:number' \
            '--force[force regeneration to occur regardless of staleness checks]' \
            '--rsync[update timestamps for rsync repos]' \
            '--use-local-desc[update local USE flag description cache (profiles/use.local.desc)]' \
            '--pkg-desc-index[update package description cache (metadata/pkg_desc_index)]' \
            '*:repo:_repos' \
            && ret=0
          ;;
        (perl-rebuild)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            ':new perl version (e.g. 5.22.0):' \
            && ret=0
          ;;
        (env-update)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            '--skip-ldconfig[do not update etc/ldso.conf and ld.so.cache]' \
            && ret=0
          ;;
        (mirror)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            {'(--ignore-failures)-f','(-f)--ignore-failures'}'[if a failure occurs, keep going]' \
            ':query:' \
            && ret=0
          ;;
        (digest)
          _arguments -C -w -S -s -A '-*' \
            $common_output_args \
            {'(--repo)-r','(-r)--repo'}'[target repository]:repo:_repos' \
            '*::ebuild:_files -g \*.ebuild' \
            && ret=0
          ;;
        (*)
          _nothing
          ;;
      esac
      ;;
  esac

  return ret
}

_pmerge() {
  local curcontext=$curcontext state state_descr line ret=1
  typeset -A opt_args

  _arguments -C \
    $domain_common_args \
    && ret=0

  return ret
}

_pquery() {
  local curcontext=$curcontext state state_descr line ret=1
  typeset -A opt_args
  typeset -a repo pkg output

  repo=(
    '--raw[disable configuration and filtering]'
    '--no-filters[disable all license filtering and visibility filtering]'
    "--virtuals[specific virtuals handling (everything is matched by default)]:options:((only\:'only match virtuals' disable\:'no matching virtuals'))"
    {'(--repo)-r','(-r)--repo'}'[target repository]:repo:_repos -e -i'
    '--all-repos[search all repos including the vdb]'
  )

  pkg=(
    '--all[match all packages (equivalent to "pquery *")]'
    '--has-use[exact string match on a USE flag]:use flag:_use -o'
    '--license[exact match on a license]:license:_licenses'
    '--herd[exact match on a herd]:herd:'
    '--revdep[shorthand for --restrict-revdep atom --print-revdep atom]:pkg atom:'
    '--revdep-pkgs[shorthand for --restrict-revdep-pkgs atom --print-revdep atom]:pkg atom:'
    '--restrict-revdep[dependency on an atom]:pkg atom:'
    '--restrict-revdep-pkgs[dependency on pkgs that match a specific atom]:pkg atom:'
    {'(--description)-S','(-S)--description'}'[regexp search on description and longdescription]:description regex'
    '--owns[exact match on an owned file/dir]:path:_files'
    '--owns-re[like "owns" but using a regexp for matching]:path regex:_files'
    '--maintainer[comma-separated list of regexes to search for maintainers]'
    '--maintainer-name[comma-separated list of maintainer name regexes to search for]'
    '--maintainer-email[comma-separated list of maintainer email regexes to search for]'
    '--environment[regexp search in environment.bz2]'
    '--pkgset[find packages that match the given package set]'
  )

  output=(
    '--early-out[stop when first match is found]'
    {'(--no-version)-n','(-n)--no-version'}'[collapse multiple matching versions together]'
    '--min[show only the lowest version for each package]'
    '--max[show only the highest version for each package]'
    '--cpv[print the category/package-version]'
    {'(--atom)-a','(-a)--atom'}'[print =cat/pkg-3 instead of cat/pkg-3 (implies --cpv, has no effect with --no-version)]'
    "--attr[print this attribute's value (can be specified more than once)]"
    '--force-attr[like --attr but accepts any string as attribute name instead of only explicitly supported names]'
    '--one-attr[print one attribute, suppresses other output]'
    '--force-one-attr[like --one-attr but accepts any string as attribute name instead of only explicitly supported names]'
    '--one-attr[print one attribute, suppresses other output]'
    '--contents[list files owned by the package]'
    '--highlight-dep[highlight dependencies matching this atom]'
    '--blame[shorthand for --attr maintainers --attr herds]'
    '--print-revdep[print what condition(s) trigger a dep]'
  )

  _arguments -C \
    $domain_common_args \
    $repo \
    $pkg \
    $output \
    && ret=0

  return ret
}

_repos() {
  # optional args
  # -c output completion format
  # -e add package.provided "repo" to the list
  # -i add vdb "repo" to the list
  # -s add repo-stack "repo" to the list
  # -v section:key
  # -p print the output instead of using completion
  # -l use repo locations instead of repo_ids
  typeset -A opts
  zparseopts -E -A opts c e i s l p v:

  local repo_name output_type
  typeset -a repos output

  if [[ -e /etc/portage/repos.conf ]]; then
    repos_conf_files=( /etc/portage/repos.conf /etc/portage/repos.conf/** )
  else
    repos_conf_files=( /usr/share/pkgcore/config/repos.conf )
  fi

  IFS='= '

  local file
  for file in "${repos_conf_files[@]}"; do
    [[ -f ${file} ]] || continue
    while read -r name value; do
      # skip comments and empty lines
      [[ -z ${name} || ${name} == '#'* ]] && continue
      if [[ (${name} == '['*']') && -z ${value} ]]; then
        repo_name=${name//(\[|\])}
        [[ ${repo_name} != "DEFAULT" ]] && repos+=(${repo_name})
        typeset -A ${repo_name}
      else
        eval "${repo_name}[${name}]=\"${value}\""
      fi
    done < ${file}
  done

  if [[ -n $opts[(I)-v] ]]; then
    section=${opts[-v]%%:*}
    value=${opts[-v]##*:}
    eval "output=\${${section}[${value}]}"
  elif [[ -n $opts[(I)-l] ]]; then
    # repo paths
    output_type="repo paths"
    for repo in $repos; do
      eval "output+=(\${${repo}[location]})"
    done
  else
    # repo names
    output_type="repos"
    [[ -n $opts[(I)-e] ]] && repos+=( provided )
    [[ -n $opts[(I)-i] ]] && repos+=( vdb )
    [[ -n $opts[(I)-s] ]] && repos+=( repo-stack )
    output=(${repos})
  fi

  if [[ -n $opts[(I)-p] ]]; then
    print $output
  else
    _describe -t repos ${output_type} output
  fi
}

_licenses() {
  # optional args
  #
  # -r repo  specify the repo to use; otherwise the default repo is used
  # -p       print the output instead of using completion
  typeset -A opts
  zparseopts -E -A opts p r:

  typeset -a licenses

  if [[ -n $opts[(I)-r] ]]; then
    repo=$opts[-r]
  else
    repo=$(_repos -p -v DEFAULT:main-repo)
  fi

  repo_path=${$(_repos -p -v "${repo}:location")%/}
  licenses=("${repo_path}"/licenses/*(.:t))

  if [[ -n $opts[(I)-p] ]]; then
    print $licenses
  else
    _describe -t licenses 'licenses' licenses
  fi
}

_use() {
  # optional args
  #
  # -r repo  specify the repo to use; otherwise the default repo is used
  # -p       print the output instead of using completion
  # -g       only show global use flags
  # -l       only show local use flags
  # -o       don't show use flag descriptions
  typeset -A opts
  zparseopts -E -A opts o p r:

  local desc
  typeset -a use use_global use_local

  if [[ -n $opts[(I)-r] ]]; then
    repo=$opts[-r]
  else
    repo=$(_repos -p -v DEFAULT:main-repo)
  fi

  repo_path=${$(_repos -p -v "${repo}:location")%/}
  [[ -f $repo_path/profiles/use.desc ]] && use_global=(${(S)${${(f)"$(<${repo_path}/profiles/use.desc)"}:#\#*}/ - /:})
  [[ -f $repo_path/profiles/use.local.desc ]] && use_local=(${(S)${(S)${${(f)"$(<${repo_path}/profiles/use.local.desc)"}:#\#*}/*:/}/ - /:})

  if [[ -z $opts[(I)-g] && -z $opts[(I)-l] ]]; then
    # both global and local use flags are shown by default
    use=( $use_global $use_local )
  elif [[ -n $opts[(I)-g] ]]; then
    use=$use_global
    desc='global '
  elif [[ -n $opts[(I)-l] ]]; then
    use=$use_local
    desc='local '
  fi

  # strip use flag descriptions
  if [[ -n $opts[(I)-o] ]]; then
    use=(${^use/:*/})
  fi

  if [[ -n $opts[(I)-p] ]]; then
    print $use
  else
    _describe -t use "${desc}use flag" use
  fi
}

_categories() {
  # optional args
  #
  # -r repo  specify the repo to use; otherwise the default repo is used
  # -p       print the output instead of using completion
  typeset -A opts
  zparseopts -E -A opts p r:

  typeset -a categories

  if [[ -n $opts[(I)-r] ]]; then
    repo=$opts[-r]
  else
    repo=$(_repos -p -v DEFAULT:main-repo)
  fi

  repo_path=${$(_repos -p -v "${repo}:location")%/}
  [[ -f $repo_path/profiles/categories ]] && categories=(${${(f)"$(<${repo_path}/profiles/categories)"}:#\#*})

  if [[ -n $opts[(I)-p] ]]; then
    print $categories
  else
    _describe -t categories 'categories' categories
  fi
}

_arches() {
  # optional args
  #
  # -r repo  specify the repo to use; otherwise the default repo is used
  # -p       print the output instead of using completion
  typeset -A opts
  zparseopts -E -A opts p r:

  typeset -a arches

  if [[ -n $opts[(I)-r] ]]; then
    repo=$opts[-r]
  else
    repo=$(_repos -p -v DEFAULT:main-repo)
  fi

  repo_path=${$(_repos -p -v "${repo}:location")%/}
  [[ -f $repo_path/profiles/arch.list ]] && arches=(${${(f)"$(<${repo_path}/profiles/arch.list)"}:#\#*})

  if [[ -n $opts[(I)-p] ]]; then
    print $arches
  else
    _describe -t arches 'arches' arches
  fi
}

_profiles() {
  # optional args
  #
  # -r repo  specify the repo to use; otherwise the default repo is used
  # -p       print the output instead of using completion
  # -f       output full, absolute profile paths
  typeset -A opts
  zparseopts -E -A opts a p f r:

  local file repo repo_path arch path pstatus
  typeset -a profiles

  if [[ -n $opts[(I)-r] ]]; then
    repo=$opts[-r]
  else
    repo=$(_repos -p -v DEFAULT:main-repo)
  fi

  repo_path=${$(_repos -p -v "${repo}:location")%/}
  file=${repo_path}/profiles/profiles.desc

  if [[ -f ${file} ]]; then
    while read -r arch path pstatus; do
      # skip comments and empty lines
      [[ -z ${arch} || ${arch} == '#'* ]] && continue
      [[ -n $opts[(I)-f] ]] && path=$repo_path/profiles/$path
      profiles+=(${path})
    done < ${file}
  fi

  if [[ -n $opts[(I)-p] ]]; then
    print $profiles
  else
    _describe -t profiles 'profiles' profiles $*
  fi
}

_pkgcore() {
  # optional args
  # -f       call an internal completion function (used to run non-service functions externally)
  #
  # Example usage: Using "_pkgcore -f repos -l" in an external completion file
  # would call the internal "repos" function with the "-l" argument causing the
  # repo location list to be returned for completion.

  typeset -A opts
  local ret=1

  if [[ $service =~ (pebuild|pinspect|pmaint|pmerge|pquery) ]]; then
    _call_function ret _$service
  else
    zparseopts -E -D -A opts f:
    if [[ -n $opts[(I)-f] ]]; then
      _call_function ret _${opts[-f]} $@
    fi
  fi

  return ret
}

_pkgcore

# vim: set et sw=2 ts=2 ft=zsh:
